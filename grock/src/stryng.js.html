<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>baseline setup - stryng.js</title>

  <link rel="stylesheet" href="../assets/style.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>
  <meta name="groc-relative-root" content="../"/>
  <meta name="groc-document-path" content="src/stryng.js"/>
  
</head>
<body>
  <div id="file-area">
    <div id="meta">
      <code class="file-path">
      
        src/stryng.js
      
      </code>
    </div>
    <div id="document">
    
      <div class="segment">
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>leverage uglifyjs&#39; ability to declare global variables</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> DEBUG === <span class="hljs-string">'undefined'</span> ) DEBUG = <span class="hljs-literal">true</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="baseline-setup"><a href="#baseline-setup" class="anchor"></a>baseline setup</h1></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">var</span> <span class="hljs-comment">// one to var them all</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to access native instance methods</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  array, object, string, regex, func,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>current version</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    VERSION = string = <span class="hljs-string">'0.0.1'</span>,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used for input validation</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    INFINITY = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to limit <em>String.fromCharCode</em></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    MAX_CHARCODE = <span class="hljs-number">65535</span>, <span class="hljs-comment">// Math.pow(2, 16) - 1</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to convert to string</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-built_in">String</span> = func = string.constructor,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>methods <em>Stryng</em> hopes to adopt</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    methods = array = ( <span class="hljs-string">'charAt,'</span> <span class="hljs-comment">// charAt</span>
      + <span class="hljs-string">'charCodeAt,'</span> <span class="hljs-comment">// charCodeAt</span>
      + <span class="hljs-string">'codePointAt,'</span> <span class="hljs-comment">// codePointAt</span>
      + <span class="hljs-string">'concat,'</span> <span class="hljs-comment">// concat</span>
      + <span class="hljs-string">'contains,'</span> <span class="hljs-comment">// contains</span>
      + <span class="hljs-string">'endsWith'</span> <span class="hljs-comment">// endsWit</span>
      + <span class="hljs-string">'indexOf,'</span> <span class="hljs-comment">// indexOf</span>
      + <span class="hljs-string">'lastIndexOf,'</span> <span class="hljs-comment">// lastIndexOf</span>
      + <span class="hljs-string">'localeCompare,'</span> <span class="hljs-comment">// localeCompare</span>
      + <span class="hljs-string">'match,'</span> <span class="hljs-comment">// match</span>
      + <span class="hljs-string">'normalize,'</span> <span class="hljs-comment">// normalize</span>
      + <span class="hljs-string">'replace,'</span> <span class="hljs-comment">// replace</span>
      + <span class="hljs-string">'search,'</span> <span class="hljs-comment">// search</span>
      + <span class="hljs-string">'slice,'</span> <span class="hljs-comment">// slice</span>
      + <span class="hljs-string">'split,'</span> <span class="hljs-comment">// split</span>
      + <span class="hljs-string">'startsWith,'</span> <span class="hljs-comment">// startsWith</span>
      + <span class="hljs-string">'substr,'</span> <span class="hljs-comment">// substr</span>
      + <span class="hljs-string">'substring,'</span> <span class="hljs-comment">// substring</span>
      + <span class="hljs-string">'toLocaleLowerCase,'</span> <span class="hljs-comment">// toLocaleLowerCase</span>
      + <span class="hljs-string">'toLocaleUpperCase,'</span> <span class="hljs-comment">// toLocaleUpperCase</span>
      + <span class="hljs-string">'toLowerCase,'</span> <span class="hljs-comment">// toLowerCase</span>
      + <span class="hljs-string">'toUpperCase,'</span> <span class="hljs-comment">// toUpperCase</span>
      + <span class="hljs-string">'trim,'</span> <span class="hljs-comment">// trim</span>
      + <span class="hljs-string">'trimLeft,'</span> <span class="hljs-comment">// trimLeft</span>
      + <span class="hljs-string">'trimRight'</span> <span class="hljs-comment">// trimRight</span>
    ).split( <span class="hljs-string">','</span> ),
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>methods which&#39;s native implementations to override if necessary</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    shim_methods = [],
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>inner module to hold type/class check functions.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    is = object = {},
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="method-shortcuts"><a href="#method-shortcuts" class="anchor"></a>method shortcuts</h2><p>create quick access variables for both native static functions
and instance methods. polyfills are reduced in functionality and byte-size.
they are thus <strong>for internal use only</strong> and neither populated onto
native prototypes nor intended to be spec-compliant.</p>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h3 id="static-methods"><a href="#static-methods" class="anchor"></a>static methods</h3></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    JSON_stringify = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">JSON</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">JSON</span>.stringify,
    Math_floor = <span class="hljs-built_in">Math</span>.floor,
    Math_random = <span class="hljs-built_in">Math</span>.random,
    String_fromCharCode = <span class="hljs-built_in">String</span>.fromCharCode,
    String_fromCodePoint = <span class="hljs-built_in">String</span>.fromCodePoint,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>fully <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.4">spec</a> compliant
implementation of <code>Number.toInteger</code>, tested and benchmarked at <a href="http://jsperf.com/to-integer/11">jsperf</a>.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    Number_toInteger = <span class="hljs-built_in">Number</span>.toInteger || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( any )</span> {</span>
      <span class="hljs-keyword">return</span> (
        ( n = +n ) &amp;&amp; <span class="hljs-built_in">isFinite</span>( n ) <span class="hljs-comment">// toNumber and isFinite</span>
        ? n - ( n % <span class="hljs-number">1</span> ) <span class="hljs-comment">// ceil negatives, floor positives</span>
        : n || <span class="hljs-number">0</span> <span class="hljs-comment">// leave be +-Infinity, translate NaN to zero</span>
      );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>try to define a dummy property on an object literal which fails<ul>
<li>either in case <code>defineProperty</code> isn&#39;t available</li>
<li>or only DOM objects are allowed as first argument</li>
</ul>
</li>
<li>if successful, return the reference to that function</li>
<li>implicitely return <code>undefined</code> otherwise</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    Object_defineProperty = ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( defineProperty )</span> {</span>
      <span class="hljs-keyword">try</span> {
        defineProperty( {}, string, {
          value: <span class="hljs-number">1</span>
        } );
        <span class="hljs-keyword">return</span> defineProperty;
      } <span class="hljs-keyword">catch</span> ( e ) {}

    } )( <span class="hljs-built_in">Object</span>.defineProperty ),
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h3 id="instance-methods"><a href="#instance-methods" class="anchor"></a>instance methods</h3></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    array_push = array.push,
    array_slice = array.slice,
    array_unshift = array.unshift,
    function_call = func.call,
    object_toString = object.toString,

    array_forEach = array.forEach || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( iterator )</span> {</span>

      <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">this</span>,
        i = array.length;

      <span class="hljs-keyword">while</span> ( i-- ) iterator( array[ i ] );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>make this one pretty for the w3c wishlist.
used in favor of the composition of <em>Array#forEach</em> and <em>Object.keys</em>.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    object_forOwn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( iterator, context )</span> {</span>

      <span class="hljs-keyword">var</span> object = <span class="hljs-keyword">this</span>,
        key, return_value;

      <span class="hljs-keyword">if</span> ( object == <span class="hljs-literal">null</span> ) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>( <span class="hljs-string">'can\'t convert '</span> + object + <span class="hljs-string">' to object'</span> );
      }

      object = <span class="hljs-built_in">Object</span>( object );

      <span class="hljs-keyword">for</span> ( key <span class="hljs-keyword">in</span> object ) {
        <span class="hljs-keyword">if</span> ( object.hasOwnProperty( key ) ) {
          return_value = iterator.call( context, object[ key ], key, object );
          <span class="hljs-keyword">if</span> ( return_value === <span class="hljs-literal">false</span> ) {
            <span class="hljs-keyword">break</span>;
          }
        }
      }
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="regular-expressions"><a href="#regular-expressions" class="anchor"></a>regular expressions</h2></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to check whether a regular expression&#39;s <code>source</code>
is suitable for reverse search. see <em>Stryng#endsWith</em> or <em>Stryng#splitRight</em>.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    re_source_matches_end = regex = <span class="hljs-regexp">/[^\\]\$$/</span>,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h3 id="diacritics-amp-liguatures"><a href="#diacritics-amp-liguatures" class="anchor"></a>diacritics &amp; liguatures</h3><p>because character mappings easily grow large we only provide
the <a href="http://unicode-table.com/en/#latin-1-supplement">Latin-1 Supplement</a>
( letters in range [u00C0-u00FF] ) mapped to their nearest character
allowed in URL path segments. this <em>should</em> cover</p>
<ul>
<li>english (of course)</li>
<li>german</li>
<li>french</li>
<li>spanish</li>
<li>portuguese</li>
<li>italian</li>
<li>romanian
we also rely on native <em>String#toLowerCase</em> and <em>String#toUpperCase</em>
to properly convert characters - <a href="javascript:alert('give me the link!')">which they don&#39;t</a></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    latin_1_supplement = {
      <span class="hljs-string">'A'</span>: <span class="hljs-string">'\\xC0-\\xC5'</span>,
      <span class="hljs-string">'a'</span>: <span class="hljs-string">'\\xE0-\\xE5'</span>,
      <span class="hljs-string">'AE'</span>:<span class="hljs-string">'\\xC6'</span>,
      <span class="hljs-string">'ae'</span>:<span class="hljs-string">'\\xE6'</span>,
      <span class="hljs-string">'C'</span>: <span class="hljs-string">'\\xC7'</span>,
      <span class="hljs-string">'c'</span>: <span class="hljs-string">'\\xE7'</span>,
      <span class="hljs-string">'E'</span>: <span class="hljs-string">'\\xC8-\\xCB'</span>,
      <span class="hljs-string">'e'</span>: <span class="hljs-string">'\\xE8-\\xEB'</span>,
      <span class="hljs-string">'I'</span>: <span class="hljs-string">'\\xCC-\\xCF'</span>,
      <span class="hljs-string">'i'</span>: <span class="hljs-string">'\\xEC-\\xEF'</span>,
      <span class="hljs-string">'D'</span>: <span class="hljs-string">'\\xD0'</span>,
      <span class="hljs-string">'d'</span>: <span class="hljs-string">'\\xF0'</span>,
      <span class="hljs-string">'N'</span>: <span class="hljs-string">'\\xD1'</span>,
      <span class="hljs-string">'n'</span>: <span class="hljs-string">'\\xF1'</span>,
      <span class="hljs-string">'O'</span>: <span class="hljs-string">'\\xD2-\\xD6\\xD8'</span>,
      <span class="hljs-string">'o'</span>: <span class="hljs-string">'\\xF2-\\xF6\\xF8'</span>,
      <span class="hljs-string">'U'</span>: <span class="hljs-string">'\\xD9-\\xDC'</span>,
      <span class="hljs-string">'u'</span>: <span class="hljs-string">'\\xF9-\\xFC'</span>,
      <span class="hljs-string">'Y'</span>: <span class="hljs-string">'\\xDD'</span>,
      <span class="hljs-string">'y'</span>: <span class="hljs-string">'\\xFD\\xFF'</span>,
      <span class="hljs-string">'sz'</span>: <span class="hljs-string">'\\xDF'</span>
    };
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>compile the character ranges to regular expressions</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  object_forOwn.call( latin_1_supplement, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( chars, nearest_char )</span> {</span>
    latin_1_supplement[ nearest_char ] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'['</span> + chars + <span class="hljs-string">']'</span>, <span class="hljs-string">'g'</span> );
  } );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h3 id="the-whitespace-shim"><a href="#the-whitespace-shim" class="anchor"></a>the whitespace shim</h3><p>native implementations of <em>String#trim</em> might miss out
on some of the more exotic characters considered <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.2">whitespace</a>,
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.3">line terminators</a> or the mysterious <a href="http://www.fileformat.info/info/unicode/category/Zs/list.html">&quot;Zs&quot;</a>.
this section detects those flaws and constructs the regular expressions used
in the polyfills and others - <a href="#splitLines">Stryng#splitLines</a> in particular.
Many thanks to the authors of <a href="http://blog.stevenlevithan.com/archives/faster-trim-javascript">faster trim</a> and <a href="http://perfectionkills.com/whitespace-deviations/">whitespace deviations</a>.</p>
<ul>
<li>let <code>re_whitespace</code> be the native white space matcher.</li>
<li>iterate over our white space characters</li>
<li>add all whitespace characters not recognized
as such to the matcher&#39;s source.</li>
<li>if the native implementation is not <code>is_spec_compliant</code>,
reconstruct the above regular expressions and mark
their associated methods as <em>to be shimmed</em></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">var</span> re_no_whitespace = <span class="hljs-regexp">/\S/</span>,
    re_whitespaces = <span class="hljs-regexp">/\s\s*/g</span>,
    re_trim_left = <span class="hljs-regexp">/^\s\s*/</span>,
    re_trim_right = <span class="hljs-regexp">/\s*\s$/</span>,
    re_linebreaks = <span class="hljs-regexp">/\r?\n|\u2028|\u2029/g</span>;

  ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">var</span> is_spec_compliant = <span class="hljs-literal">true</span>,
      re_whitespace = <span class="hljs-regexp">/\s/</span>,
      re_whitespace_source = re_whitespace.source,

      whitespace = ( <span class="hljs-string">''</span> + <span class="hljs-string">'\t'</span> <span class="hljs-comment">// '\u0009' tab</span>
        + <span class="hljs-string">'\n'</span> <span class="hljs-comment">// '\u000A' line feed</span>
        + <span class="hljs-string">'\13'</span> <span class="hljs-comment">// '\u000B' vertical tab</span>
        + <span class="hljs-string">'\f'</span> <span class="hljs-comment">// '\u000C' form feed</span>
        + <span class="hljs-string">'\r'</span> <span class="hljs-comment">// '\u000D' carriage return</span>
        + <span class="hljs-string">' '</span> <span class="hljs-comment">// '\u0020' space</span>

        + <span class="hljs-string">'\xA0'</span> <span class="hljs-comment">// NBSP</span>
        + <span class="hljs-string">'\u1680\u180E\u2000\u2001'</span> <span class="hljs-comment">// prevent</span>
        + <span class="hljs-string">'\u2002\u2003\u2004\u2005'</span> <span class="hljs-comment">// formatter</span>
        + <span class="hljs-string">'\u2006\u2007\u2008\u2009'</span> <span class="hljs-comment">// from</span>
        + <span class="hljs-string">'\u200A\u202F\u205F\u3000'</span> <span class="hljs-comment">// mangling</span>

        + <span class="hljs-string">'\u2028'</span> <span class="hljs-comment">// line separator</span>
        + <span class="hljs-string">'\u2029'</span> <span class="hljs-comment">// paragraph separator</span>
        + <span class="hljs-string">'\uFEFF'</span> <span class="hljs-comment">// BOM - byte order mark</span>
      );

    array_forEach.call( whitespace, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( chr )</span> {</span> <span class="hljs-comment">// Array#forEach is generic</span>

      <span class="hljs-keyword">if</span> ( !re_whitespace.test( chr ) ) {
        re_whitespace_source += chr;
        is_spec_compliant = <span class="hljs-literal">false</span>;
      }

    } );

    <span class="hljs-keyword">if</span> ( !is_spec_compliant ) {

      shim_methods.push( <span class="hljs-string">'trim'</span>, <span class="hljs-string">'trimRight'</span>, <span class="hljs-string">'trimLeft'</span> );

      <span class="hljs-keyword">var</span> re_whitespaces_source = <span class="hljs-string">'['</span> + re_whitespace_source + <span class="hljs-string">']['</span> + re_whitespace_source + <span class="hljs-string">']*'</span>;

      re_no_whitespace = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'[^'</span> + re_whitespace_source + <span class="hljs-string">']'</span> );
      re_whitespaces = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( re_whitespaces_source, <span class="hljs-string">'g'</span> );
      re_trim_left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'^'</span> + re_whitespaces_source );
      re_trim_right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'['</span> + re_whitespace_source + <span class="hljs-string">']+$'</span> );
    }

  }() );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="the-substr-check"><a href="#the-substr-check" class="anchor"></a>the <code>substr</code> check</h2><p>check to see if the native implementation
correctly deals with negative indices.
mark as <em>to be shimmed</em> if it doesn&#39;t.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">if</span> ( <span class="hljs-string">'xy'</span>.substr( -<span class="hljs-number">1</span> ) !== <span class="hljs-string">'y'</span> ) shim_methods.push( <span class="hljs-string">'substr'</span> );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="custom-exit"><a href="#custom-exit" class="anchor"></a>custom exit</h2><p>wraps the process of throwing an <em>Error</em>.
in <em>DEBUG</em> mode composes the error&#39;s message
of the custom <em>Stryng</em> function&#39;s <code>_name</code> property
and the arguments passed i.e. logs the stacktrace of the level above.</p>
<ul>
<li>get the <code>caller</code> function</li>
<li>stringify its arguments</li>
<li>throw the error with the custom message</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exit</span><span class="hljs-params">( message )</span> {</span>
    <span class="hljs-keyword">if</span> ( DEBUG ) {

      <span class="hljs-keyword">var</span> args = <span class="hljs-string">''</span>,
        caller = <span class="hljs-built_in">arguments</span>.callee.caller,
        caller_args = caller.arguments,
        caller_args_len = caller_args.length,
        i = <span class="hljs-number">0</span>,
        message = <span class="hljs-string">'invalid usage of Stryng.'</span> + caller._name + <span class="hljs-string">'() with args ['</span>;

      <span class="hljs-keyword">for</span>(; i &lt; caller_args_len; i++ ){
        args += caller_args[i] + <span class="hljs-string">','</span>;
      }

      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( message + ( args ? args.slice( <span class="hljs-number">0</span>, -<span class="hljs-number">2</span> ) : <span class="hljs-string">''</span> ) + <span class="hljs-string">']. '</span> + ( message || <span class="hljs-string">''</span> ) );

    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">'invalid usage of Stryng member. '</span> + ( message || <span class="hljs-string">''</span> ) );
    }
  }
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="type-safety"><a href="#type-safety" class="anchor"></a>type safety</h2><p>the inner module <code>is</code> holds type checks. this is an excerpt from
my <a href="https://gist.github.com/esnippo/9960508">gist</a> inspired by the
<a href="http://jquery.com">jQuery</a> and <a href="http://underscorejs.org">underscore</a> libraries.</p>
<ul>
<li>provide quick access to precomputed <code>repr</code> within <em>Array#forEach</em> closure</li>
<li>early exit on &quot;falsies&quot;</li>
<li>apply native implementations where available</li>
<li>fix old webkit&#39;s bug where <code>typeof regex</code> yields <code>&#39;function&#39;</code> </li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  array_forEach.call( [ <span class="hljs-string">'Array'</span>, <span class="hljs-string">'Function'</span>, <span class="hljs-string">'RegExp'</span> ], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( klass )</span> {</span>

    <span class="hljs-keyword">var</span> repr = <span class="hljs-string">'[object '</span> + klass + <span class="hljs-string">']'</span>;
    is[ klass ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( any )</span> {</span>
      <span class="hljs-keyword">return</span> any &amp;&amp; object_toString.call( any ) === repr;
    };

  } );

  is.Array = <span class="hljs-built_in">Array</span>.isArray || is.Array;

  <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> regex === <span class="hljs-string">'object'</span> ) {
    is.Function = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( any )</span> {</span>
      <span class="hljs-keyword">return</span> any &amp;&amp; <span class="hljs-keyword">typeof</span> any === <span class="hljs-string">'function'</span>;
    };
  }
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="defining-stryng"><a href="#defining-stryng" class="anchor"></a>defining Stryng</h1></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="constructor"><a href="#constructor" class="anchor"></a>constructor</h2></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 class Stryng
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>value</code> is optional, must be a *, and has a default value of &quot;&quot;.</strong><br/>(the value to parse. defaults to the empty string)</li>
<li><strong><code>is_mutable</code> is optional, must be a boolean, and has a default value of false.</strong><br/>(whether the created instance should be mutable or create a new instance from the result of every method call)</li>
</ul>
<p><strong>Returns a Stryng</strong><br/>(- the <code>input</code>&#39;s string representation wrapped in the instance returned.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stryng</span><span class="hljs-params">( value, is_mutable )</span> {</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>allow omitting the new operator</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( !( <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Stryng ) ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( value );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 name Stryng~<em>value and of type _string</em>
</span></p>
<p>the wrapped native string primitive</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">this</span>._value = value != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( value ) : <span class="hljs-string">''</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 name Stryng~<em>is_mutable and of type _boolean</em>
</span></p>
<p>whether the created instance should be mutable or
create a new instance from the result of every method call</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">this</span>._is_mutable = !! is_mutable;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 name Stryng#length and of type <em>number</em>
</span></p>
<p>the <a href="#_value">String#_value</a>&#39;s length defined via <em>Object.defineProperty</em>
if available, simply set onto the instance otherwise.</p>
<p>TODO: further <a href="http://www.2ality.com/2012/08/property-definition-assignment.html">reading</a></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( Object_defineProperty ) {
      Object_defineProperty( <span class="hljs-keyword">this</span>, <span class="hljs-string">'length'</span>, {
        enumerable: <span class="hljs-literal">false</span>,
        configurable: <span class="hljs-literal">false</span>,
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value.length
        }
      } );
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.length = <span class="hljs-keyword">this</span>._value.length;
    }
  }
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><h2 id="cloning-mutables"><a href="#cloning-mutables" class="anchor"></a>cloning mutables</h2><p>in case the instance was not constructed to be mutable
this is the hook to get a copy of it. delegates to <a href="#Stryng">Stryng#constructor</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>is_mutable</code> is optional, must be a boolean, and has a default value of false.</strong><br/>(whether the cloned instance should be mutable or create a new instance from the internal result of every method call)</li>
</ul>
<p><strong>Returns a Stryng</strong><br/>(- a copy of the <em>Stryng</em> instance)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  Stryng.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( is_mutable )</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( <span class="hljs-keyword">this</span>._value, is_mutable );
  };
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="instance-methods-amp-static-functions"><a href="#instance-methods-amp-static-functions" class="anchor"></a>instance methods &amp; static functions</h2><p>the herein defined methods will be available as both
static functions on the <code>Stryng</code> namespace and instance methods
of the <code>Stryng</code> class. they are declared as static but <strong>documented as
instance methods</strong>, which makes it a lot shorter, less verbose and
easier to highlight the fact that all instance methods are availabe
as static ones but <strong>not vice versa</strong>. the one exception to this is <a href="#clone">Stryng#clone</a>
which only lives on <em>Stryng</em>&#39;s prototype.</p>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 lends Stryng.prototype
</span></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">var</span> stryng_members = {
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.20">String#trim</a></p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    trim: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ?
        <span class="hljs-built_in">String</span>( input )
        .replace( re_trim_left, <span class="hljs-string">''</span> )
        .replace( re_trim_right, <span class="hljs-string">''</span> ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for non-standard <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/TrimLeft">String#trimLeft</a></p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    trimLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).replace( re_trim_left, <span class="hljs-string">''</span> ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for non-standard <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/TrimRight">String#trimRight</a></p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    trimRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).replace( re_trim_right, <span class="hljs-string">''</span> ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains">String#contains</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>search</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>index</code> is optional, must be a number, and has a default value of 0.</strong><br/>(the index to start searching)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not <code>input</code> contains the substring <code>search</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    contains: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, search, start )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).indexOf( search, start ) !== -<span class="hljs-number">1</span> : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.startswith">String#startsWith</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>search</code> is optional, can be a string or a RegExp, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>position</code> is optional, must be a number, and has a default value of 0.</strong></li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not <code>input</code> at index <code>position</code> begins with substring <code>search</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    startsWith: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, search, position )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>if <code>search</code> is a regular expression,
return whether or not it matches the beginning of
this&#39; string starting at <code>position</code>.</li>
<li>otherwise let <code>i</code> be the index returned by <em>String#indexOf</em>.
let <code>position</code> and <code>search</code> be parsed correctly internally</li>
<li>return <code>false</code> if not found i.e. <code>i === -1</code></li>
<li>let <code>input_len</code> be this&#39; string&#39;s length</li>
<li>parse the <code>position</code> argument by the following rules<ul>
<li>default and min to zero</li>
<li>max to <code>input_len</code></li>
<li>floor if positive parsable, zero if <code>NaN</code></li>
</ul>
</li>
<li>return whether or not <code>i</code> equals the above&#39;s result</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( is.RegExp( search ) ) {
        <span class="hljs-keyword">return</span> !input.substring( position ).search( search );
      }

      <span class="hljs-keyword">var</span> i = input.indexOf( search, position ),
        input_len;

      <span class="hljs-keyword">if</span> ( i === -<span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

      input_len = input.length;
      <span class="hljs-keyword">return</span> i === (
        position === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> || position &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> :
        position &gt; input_len ? input_len :
        Math_floor( position ) || <span class="hljs-number">0</span>
      );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.endswith">String#endsWith</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>search</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>end_position</code> is optional, must be a number, and has a default value of input.length.</strong></li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not <code>input</code> truncated by <code>end_position</code> ends with substring <code>search</code>.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    endsWith: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, search, end_position )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>let <code>input_len</code> be this&#39; string&#39;s length</li>
<li>parse the <code>end_position</code> argument by the following rules<ul>
<li>default and max to <code>input_len</code></li>
<li>min to zero</li>
<li>floor if parsable, zero if <code>NaN</code></li>
</ul>
</li>
<li>if <code>search</code> is a regular expression<ul>
<li>throw an error if the regular expression does not match the
end of its input i.e. does not end with <code>&#39;$&#39;</code></li>
<li>truncate this&#39; string at <code>end_position</code></li>
<li>return whether or not <code>search</code> matches the above&#39;s result</li>
</ul>
</li>
<li>otherwise let <code>i</code> be the index returned by <em>String#lastIndexOf</em>.
let <code>position</code> and <code>search</code> be parsed correctly internally</li>
<li>return <code>false</code> if not found i.e. <code>i === -1</code></li>
<li>return whether or not <code>i</code> equals the above&#39;s result</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">var</span> input_len = input.length,
        i,
        end_position = (
          end_position === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> || end_position &gt; input_len ? input_len :
          end_position &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> :
          Math_floor( end_position ) || <span class="hljs-number">0</span>
        );

      <span class="hljs-keyword">if</span> ( is.RegExp( search ) ) {

        <span class="hljs-keyword">if</span> ( !re_source_matches_end.test( search.source ) ) {
          exit( <span class="hljs-string">'"search" must match end i.e. end with "$"'</span> );
        }

        <span class="hljs-keyword">return</span> search.test( input.substring( <span class="hljs-number">0</span>, end_position ) );
      }

      search = <span class="hljs-built_in">String</span>( search );

      <span class="hljs-keyword">if</span> ( !search ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

      i = input.lastIndexOf( search, end_position );

      <span class="hljs-keyword">return</span> i !== -<span class="hljs-number">1</span> &amp;&amp; ( i + search.length === end_position );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.repeat">String#repeat</a>.
reduction of concat operations inspired by <a href="https://github.com/mout/mout/blob/v0.9.0/src/string/repeat.js">mout/string/repeat</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 0.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- this&#39; string <code>n</code> times concatenated to the empty string.)<br/><strong>and</strong> If <code>Number_toInteger( n )</code> is either negative or infinite.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    repeat: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, n )</span> {</span>
      <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || n &lt;= -<span class="hljs-number">1</span> || n == INFINITY ) exit();

      n = n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( n ) || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">while</span> ( n ) {
        <span class="hljs-keyword">if</span> ( n % <span class="hljs-number">2</span> ) {
          result += input;
        }
        n = Math_floor( n / <span class="hljs-number">2</span> );
        input += input;
      }
      <span class="hljs-keyword">return</span> result;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.substr">String#substr</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>position</code> is optional, must be a number, and has a default value of 0.</strong></li>
<li><strong><code>length</code> is optional, must be a number, and has a default value of length-position.</strong><br/>(this&#39; string&#39;s length minus <code>position</code>)</li>
</ul>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    substr: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, position, length )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse the <code>position</code> argument.<ul>
<li>if <code>Number_toInteger( position )</code> is negative, add <code>input.length</code></li>
<li>if it still is negative, set it to zero</li>
</ul>
</li>
<li>leave it up to <code>substr</code>&#39;s implicit parsing any otherwise</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      position = position &lt;= -<span class="hljs-number">1</span> ? ( position = Number_toInteger( position ) + input.length ) &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : position : position;

      <span class="hljs-keyword">return</span> input.substr( position, length );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 requires Stryng#repeat
</span></p>
<p>prepends and appends <code>outfix</code> to <code>input</code> in one go.
to do the opposite use <a href="#strip">Stryng.strip</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>outfix</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(prefix and suffix)</li>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 0.</strong><br/>(number of operations)</li>
</ul>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    wrap: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, outfix, n )</span> {</span>
      <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> ) exit();</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>outfix</code> and <code>n</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      outfix = Stryng.repeat( outfix, n );
      <span class="hljs-keyword">return</span> outfix + input + outfix;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>search</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(substring to search for)</li>
</ul>
<p><strong>Returns a number</strong><br/>(- number of non-overlapping occurrences of <code>search</code> within <code>input</code>. the empty string is considered a <em>character boundary</em> thus <code>input.length + 1</code> will always be the result for that.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    count: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, search )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

      search = <span class="hljs-built_in">String</span>( search );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty search</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( !search ) <span class="hljs-keyword">return</span> input.length + <span class="hljs-number">1</span>;

      <span class="hljs-keyword">var</span> length = search.length,
        count = <span class="hljs-number">0</span>,
        i = -length; <span class="hljs-comment">// prepare first run</span>

      <span class="hljs-keyword">do</span> i = input.indexOf( search, i + length );
      <span class="hljs-keyword">while</span> ( i !== -<span class="hljs-number">1</span> &amp;&amp; ++count )

      <span class="hljs-keyword">return</span> count;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>delegates to <em>Arrray#join</em>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>joinees</code> is optional, must be any number of strings, and has a default value of [.</strong><br/>(])</li>
</ul>
<p><strong>Returns a string</strong><br/>(- <code>joinees</code> joined by native <code>Array.prototype.join</code>. return the empty string if no second, third .. argument is passed)</p>
<p>Example:</p>
<pre><code>Stryng.join(<span class="hljs-string">' '</span>, <span class="hljs-operator">the</span><span class="hljs-string">', ['</span>quick<span class="hljs-string">', ['</span>brown<span class="hljs-string">', ['</span>fox<span class="hljs-string">']]]); // yeilds '</span><span class="hljs-operator">the</span> quick brown fox<span class="hljs-string">'</span>
</code></pre></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    join: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( delimiter <span class="hljs-comment">/*, string... */</span> )</span> {</span>
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>; <span class="hljs-comment">// promote compression</span>

      <span class="hljs-keyword">if</span> ( delimiter == <span class="hljs-literal">null</span> ) exit();
      <span class="hljs-keyword">if</span> ( args.length === <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;

      <span class="hljs-keyword">return</span> array_slice.call( args, <span class="hljs-number">1</span> ).join( delimiter );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>this is a naive implementation of reversing a string.
for an alternative that know how to properly reverse
diacritics and accented character use <a href="https://github.com/mathiasbynens/esrever">esrever</a>.</p>
<p><strong>Returns a string</strong><br/>(- the reversed string. usefull yet unefficient to verify palindroms.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    reverse: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input )
        .split( <span class="hljs-string">''</span> )
        .reverse()
        .join( <span class="hljs-string">''</span> ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>position</code> is optional, must be a number, and has a default value of 0.</strong><br/>(index of insertion, can be negative)</li>
<li><strong><code>insertion</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> split at <code>position</code> and rejoined using <code>insertion</code> as the delimiter)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    insert: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, position, insertion )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>slice&#39;s native parsing will apply different
defaults for <code>undefined</code> to the first and second argument</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( position === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ) position = Number_toInteger( position );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>insertion</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">return</span> input.slice( <span class="hljs-number">0</span>, position ) + insertion + input.slice( position );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>delimiter</code> is optional, can be a string or a RegExp, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>n</code> is optional, must be a number, and has a default value of Math.pow(2,32)-1.</strong><br/>(maximum number of split operations. as per <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.14">ecma-262/5.1</a>)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- the <code>input</code> split by the given <code>delimiter</code> with anything past the <code>n</code>th occurrence of <code>delimiter</code> untouched yet included in the array.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    splitLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, delimiter, n )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>return the empty array if <code>n</code> is zero</li>
<li>let <code>result</code> be the array to return</li>
<li>if <code>delimiter</code> is a regular expression<ul>
<li>extract <code>n</code> matches using <em>String#match</em> combined with
subsequently front-cutting this&#39; string. using <em>RegExp#exec</em>
would require the regex&#39;s <em>global</em> flag to be set.</li>
<li>push the substrings between the matches and any captured groups to <code>result</code></li>
</ul>
</li>
<li>otherwise let <code>result</code> be the result of <em>String#split</em>
called on this&#39; string with <code>delimiter</code></li>
<li>if argument <code>n</code> is lesser than <code>result.length</code><ul>
<li>remove the last <code>result.length - n</code> items from <code>result</code></li>
<li>rejoin them using <code>delimiter</code></li>
<li>push them to <code>result</code> as one</li>
</ul>
</li>
<li>return <code>result</code></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> ( !n ) <span class="hljs-keyword">return</span> [];

      <span class="hljs-keyword">var</span> result = [],
        match,
        index,
        lastIndex = <span class="hljs-number">0</span>,
        diff;

      <span class="hljs-keyword">if</span> ( is.RegExp( delimiter ) ) {
        <span class="hljs-keyword">while</span> ( n-- &amp;&amp; ( match = input.match( delimiter ) ) ) {
          index = match.index;
          result.push( input.substring( <span class="hljs-number">0</span>, index ) );
          lastIndex = index + match.shift().length; <span class="hljs-comment">// mutates `match`</span>
          <span class="hljs-keyword">if</span> ( lastIndex &lt;= index ) lastIndex = index + <span class="hljs-number">1</span>; <span class="hljs-comment">// avoid endless loop</span>
          <span class="hljs-keyword">if</span> ( match.length ) array_push.apply( result, match ); <span class="hljs-comment">// mutate instead of recreate as concat would</span>
          input = input.substring( lastIndex );
        }
        result.push( input ); <span class="hljs-comment">// push what's left</span>
      } <span class="hljs-keyword">else</span> {
        delimiter = <span class="hljs-built_in">String</span>( delimiter );
        result = input.split( delimiter );
        diff = result.length - n;
        <span class="hljs-keyword">if</span> ( diff &gt; <span class="hljs-number">0</span> ) {
          result.push( result.splice( n, diff ).join( delimiter ) ); <span class="hljs-comment">// implies parsing delimiter</span>
        }
      }

      <span class="hljs-keyword">return</span> result;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>the right-associative version of <a href="#splitLeft">Stryng.splitLeft</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>delimiter</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>n</code> is optional, must be a number, and has a default value of Math.pow(2,32)-1.</strong><br/>(maximum number of split operations. defaults to the number of non-overlapping occurrences of <code>delimiter</code>)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- the <code>input</code> split by the given <code>delimiter</code> with anything in front of the <code>n</code>th occurrence of <code>delimiter</code> - counting backwards - untouched yet included in the array.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    splitRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, delimiter, n )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>return the empty array if <code>n</code> is zero</li>
<li>if <code>delimiter</code> is a regular expression<ul>
<li>check its source if it matches a string&#39;s end by <code>$</code></li>
<li>extract <code>n</code> matches using <em>String#match</em> combined with
subsequently truncating this&#39; string.</li>
<li>unshift the substrings between the matches and any captured groups to <code>result</code></li>
</ul>
</li>
<li>otherwise let <code>result</code> be the result of <em>String#split</em>
called on this&#39; string with <code>delimiter</code></li>
<li>if argument <code>n</code> is lesser than <code>result.length</code><ul>
<li>remove the first <code>n</code> items from <code>result</code></li>
<li>rejoin them using <code>delimiter</code></li>
<li>unshift them to <code>result</code> as one</li>
</ul>
</li>
<li>return <code>result</code></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> ( !n ) <span class="hljs-keyword">return</span> [];

      <span class="hljs-keyword">var</span> result,
        index,
        lastIndex,
        match,
        diff;

      <span class="hljs-keyword">if</span> ( is.RegExp( delimiter ) ) {

        <span class="hljs-keyword">if</span> ( !re_source_matches_end.test( delimiter.source ) ) {
          exit( <span class="hljs-string">'"delimiter" must match end i.e. end with "$"'</span> );
        }

        <span class="hljs-keyword">while</span> ( n-- &amp;&amp; ( match = input.match( delimiter ) ) ) {
          index = match.index;
          lastIndex = index + match.shift().length; <span class="hljs-comment">// mutates `match`</span>
          result.unshift( input.substring( lastIndex ) );
          <span class="hljs-keyword">if</span> ( index &gt;= lastIndex ) index = lastIndex - <span class="hljs-number">1</span>; <span class="hljs-comment">// avoid endless loop</span>
          <span class="hljs-keyword">if</span> ( match.length ) array_unshift.apply( result, match ); <span class="hljs-comment">// mutate instead of recreate as concat would</span>
          input = input.substring( <span class="hljs-number">0</span>, index );
        }
        result.unshift( input ); <span class="hljs-comment">// unshift what's right</span>
      } <span class="hljs-keyword">else</span> {

        delimiter = <span class="hljs-built_in">String</span>( delimiter );
        result = input.split( delimiter ),
        diff = result.length - n;

        <span class="hljs-keyword">if</span> ( diff &gt; <span class="hljs-number">0</span> ) {
          result.unshift( result.splice( <span class="hljs-number">0</span>, diff ).join( delimiter ) );
        }
      }

      <span class="hljs-keyword">return</span> result;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.3">http://www.ecma-international.org/ecma-262/5.1/#sec-7.3</a>
</span></p>
<p><strong>Returns a string[]</strong><br/>(- <code>input</code> split by line-terminators as defined within the spec)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    splitLines: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).split( re_linebreaks ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>splits a string at the given indices. negative indices are allowed.
if the resulting substrings overlap, the first one dominates, the latter is front-cut.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>index</code> must be any number of numbers.</strong><br/>(indices to split at. negatives allowed)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- the resulting array of substrings.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    splitAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input <span class="hljs-comment">/*, index... */</span> )</span> {</span>
      input = intput != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>for each index<ul>
<li>if it is negative, add this&#39; string&#39;s length</li>
<li>apply <code>pending_index</code> of the previous iteration ( initially zero ) as <code>index</code>&#39;s minimum</li>
<li>let native <em>String#slice</em> apply the maximum</li>
<li>push what&#39;s within input between <code>pending_index</code> and <code>index</code> to <code>result</code></li>
<li>update <code>pending_index</code> for the next iteration</li>
</ul>
</li>
<li>push what&#39;s left to the result and return it.</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">var</span> input_len = input.length,
        args = <span class="hljs-built_in">arguments</span>,
        args_len = args.length,
        i = <span class="hljs-number">1</span>, <span class="hljs-comment">// skip `input`</span>
        index = <span class="hljs-number">0</span>,
        pending_index = <span class="hljs-number">0</span>,
        result = [];

      <span class="hljs-keyword">for</span> ( ; i &lt; args_len; i++ ) {
        index = Number_toInteger( args[ i ] );
        <span class="hljs-keyword">if</span> ( index &lt; <span class="hljs-number">0</span> ) {
          index += input_len;
        }
        <span class="hljs-keyword">if</span> ( index &lt;= pending_index ) {
          result.push( <span class="hljs-string">''</span> ); <span class="hljs-comment">// faster than slicing the empty string first</span>
          index = pending_index;
        } <span class="hljs-keyword">else</span> {
          result.push( input.slice( pending_index, index ) );
          pending_index = index;
        }
      }
      result.push( input.substring( index ) );
      <span class="hljs-keyword">return</span> result;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>replacee</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to replace)</li>
<li><strong><code>replacement</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(replacement)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> with all non-overlapping occurrences of <code>replacee</code> replaced by <code>replacement</code>.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    exchange: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, replacee, replacement )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      replacee = <span class="hljs-built_in">String</span>( replacee );
      replacement = <span class="hljs-built_in">String</span>( replacement );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for equality</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( replacee === replacement ) <span class="hljs-keyword">return</span> input;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">return</span> input.split( replacee ).join( replacement );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng#exchangeRight
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>replacee</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to replace)</li>
<li><strong><code>replacement</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(replacement)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of replacement operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- this&#39; string with <code>n</code> left-hand non-overlapping occurrences of <code>replacee</code> replaced by <code>replacement</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    exchangeLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, replacee, replacement, n )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      replacee = <span class="hljs-built_in">String</span>( replacee );
      replacement = <span class="hljs-built_in">String</span>( replacement );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for equality</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( replacee === replacement ) <span class="hljs-keyword">return</span> input;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">return</span> Stryng.splitLeft( input, replacee, n ).join( replacement );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng.exchangeLeft, Stryng.exchange
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>replacee</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to replace)</li>
<li><strong><code>replacement</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(replacement)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of replacement operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> with <code>n</code> right-hand non-overlapping occurrences of <code>replacee</code> replaced by <code>replacement</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    exchangeRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, replacee, replacement, n )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      replacee = <span class="hljs-built_in">String</span>( replacee );
      replacement = <span class="hljs-built_in">String</span>( replacement );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for equality</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( replacee === replacement ) <span class="hljs-keyword">return</span> input;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">return</span> Stryng.splitRight( input, replacee, n ).join( replacement );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng.justLeft, Stryng.justRight
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>max_len</code> must be a number.</strong></li>
<li><strong><code>fill</code> must be a string.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(the <code>input</code> with <code>fill</code> appended as often as needed for <code>input</code> to reach but not exceed a length of <code>max_len</code>. this&#39; string is never truncated.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    just: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, max_len, fill )</span> {</span>
      <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || max_len &lt;= -<span class="hljs-number">1</span> || max_len == INFINITY ) exit();

      input = <span class="hljs-built_in">String</span>( input );
      fill = <span class="hljs-built_in">String</span>( fill );
      max_len = max_len &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( max_len ) || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> input_len = input.length,
        fill_len = fill.length * <span class="hljs-number">2</span>; <span class="hljs-comment">// safe, `&lt;&lt; 1` isn't</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty fill</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( max_len &lt;= input_len || !fill ) <span class="hljs-keyword">return</span> input;

      <span class="hljs-keyword">while</span> ( input.length + fill_len &lt;= max_len ) {
        input = fill + input + fill;
      }

      <span class="hljs-keyword">return</span> input;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng#justRight, Stryng#just
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>max_len</code> must be a number.</strong></li>
<li><strong><code>fill</code> must be a string.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> with <code>fill</code> prepended as often as needed for <code>input</code> to reach but not exceed a length of <code>max_len</code>. this&#39; string is never truncated.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    justLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, max_len, fill )</span> {</span>
      <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || max_len &lt;= -<span class="hljs-number">1</span> || max_len == INFINITY ) exit();

      input = <span class="hljs-built_in">String</span>( input );
      fill = <span class="hljs-built_in">String</span>( fill );
      max_len = max_len &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( max_len ) || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> input_len = input.length;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty fill</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( max_len &lt;= input_len || !fill ) <span class="hljs-keyword">return</span> input;

      <span class="hljs-keyword">var</span> fill_len = fill.length;

      <span class="hljs-keyword">while</span> ( input.length + fill_len &lt;= max_len ) {
        input = fill + input;
      }

      <span class="hljs-keyword">return</span> input;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng.justLeft, Stryng.just
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>max_len</code> must be a number.</strong></li>
<li><strong><code>fill</code> must be a string.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(the <code>input</code> with <code>fill</code> appended as often as needed for <code>input</code> to reach but not exceed a length of <code>max_len</code>. this&#39; string is never truncated.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    justRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, max_len, fill )</span> {</span>
      <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || max_len &lt;= -<span class="hljs-number">1</span> || max_len == INFINITY ) exit();

      input = <span class="hljs-built_in">String</span>( input );
      fill = <span class="hljs-built_in">String</span>( fill );
      max_len = max_len &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( max_len ) || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> input_len = input.length
      fill_len = fill.length;

      <span class="hljs-keyword">if</span> ( max_len &lt;= input_len || !fill ) <span class="hljs-keyword">return</span> input;

      <span class="hljs-keyword">while</span> ( input.length + fill_len &lt;= max_len ) {
        input += fill;
      }

      <span class="hljs-keyword">return</span> input;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>strips <code>prefix</code> from the left of <code>input</code> <code>n</code> times.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>prefix</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to remove)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(-)</p>
<p>Example:</p>
<p>Stryng.stripLeft(&#39;lefty loosy&#39;, &#39;lefty &#39;);
// return &#39;loosy&#39;</p>
<p>Stryng.stripLeft(&#39;blubblubblub&#39;, &#39;blub&#39;);
// return the empty string</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    stripLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, prefix, n )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>parse <code>prefix</code> to string</li>
<li>early exit before processing senseless arguments</li>
<li>set an index <code>pending_i</code> to zero</li>
<li>increment it by <code>prefix.length</code> as long as fast native
<em>String#indexOf</em> return just the result of that addition
and we are not running out of <code>n</code>.</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;
      prefix = <span class="hljs-built_in">String</span>( prefix );

      <span class="hljs-keyword">if</span> ( !n || !prefix ) <span class="hljs-keyword">return</span> input;

      <span class="hljs-keyword">var</span>
      prefix_len = prefix.length,
        pending_i = <span class="hljs-number">0</span>,
        i;

      <span class="hljs-keyword">do</span> i = input.indexOf( prefix, pending_i );
      <span class="hljs-keyword">while</span> ( n-- &amp;&amp; i === pending_i &amp;&amp; ( pending_i += prefix_len ) );

      <span class="hljs-keyword">return</span> pending_i ? input.substring( pending_i ) : input;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>the right-associative version of <a href="#stripLeft">Stryng.stripLeft</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>suffix</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to remove)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(-)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    stripRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, suffix, n )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>parse <code>suffix</code> to string</li>
<li>early exit before processing senseless arguments</li>
<li>set an index <code>p</code> to <code>input.length</code></li>
<li>decrement it by <code>suffix.length</code> as long as fast native
<em>String#lastIndexOf</em> return just the result of that subtraction
and we are not running out of <code>n</code>.</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;
      suffix = <span class="hljs-built_in">String</span>( suffix );

      <span class="hljs-keyword">if</span> ( !n || !suffix ) <span class="hljs-keyword">return</span> input;

      <span class="hljs-keyword">var</span>
      suffix_len = suffix.length,
        pending_i = input.length,
        i;

      <span class="hljs-keyword">do</span> {
        pending_i -= suffix_len;
        i = input.lastIndexOf( suffix, pending_i );
      }
      <span class="hljs-keyword">while</span> ( n-- &amp;&amp; i !== -<span class="hljs-number">1</span> &amp;&amp; i === pending_i );

      <span class="hljs-keyword">return</span> input.substring( <span class="hljs-number">0</span>, pending_i + suffix_len );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>the combination of <a href="#stripLeft">Stryng.stripLeft</a> and <a href="#stripRight">Stryng.stripRight</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>outfix</code> must be a string.</strong><br/>(string to remove)</li>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 1.</strong><br/>(number of operations (recursion depth))</li>
</ul>
<p><strong>Returns a string</strong><br/>(-)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    strip: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, outfix, n )</span> {</span>
      <span class="hljs-keyword">return</span> Stryng.stripRight( Stryng.stripLeft( input, outfix, n ), outfix, n );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>max_len</code> must be a number.</strong><br/>(length of the result.)</li>
<li><strong><code>ellipsis</code> is optional, must be a string, and has a default value of &quot;...&quot;.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> sliced to fit the given <code>max_len</code> including the <code>ellipsis</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    truncate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, max_len, ellipsis )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>max_len</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>if <code>max_len</code> is zero return the empty string</li>
<li>if <code>max_len</code> is bigger than <code>input.length</code>
there&#39;s to need to truncate, return this&#39; string</li>
<li>parse <code>ellipsis</code> to string, default to <code>&#39;...&#39;</code></li>
<li>if <code>ellipsis.length</code> is bigger than <code>max_len</code>,
return the last <code>max_len</code> characters of <code>ellipsis</code></li>
<li>return the concatenation of this&#39; string&#39;s first
<code>max_len - ellipsis_len</code> characters and <code>ellipsis</code></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      max_len = ( max_len === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : max_len ) &gt;&gt;&gt; <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> ( !max_len ) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      <span class="hljs-keyword">if</span> ( max_len &gt;= input.length ) <span class="hljs-keyword">return</span> input;

      ellipsis = ellipsis !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-built_in">String</span>( ellipsis ) : <span class="hljs-string">'...'</span>;

      <span class="hljs-keyword">var</span> ellipsis_len = ellipsis.length;

      <span class="hljs-keyword">if</span> ( ellipsis_len &gt;= max_len ) <span class="hljs-keyword">return</span> ellipsis.slice( -max_len );

      <span class="hljs-keyword">return</span> input.substring( <span class="hljs-number">0</span>, max_len - ellipsis_len ) + ellipsis;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    quote: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>delegate to native <em>JSON.stringify</em> if available</li>
<li>fast forwardly iterate over this&#39; string otherwise<ul>
<li>preserve ASCII printables</li>
<li>use short escape characters</li>
<li>use hexadecimal notation as a last resort, whichever is shortest</li>
</ul>
</li>
<li>wrap <code>result</code> in double quotes and return it</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">      <span class="hljs-keyword">if</span> ( JSON_stringify ) {
        <span class="hljs-keyword">return</span> JSON_stringify( input );
      }

      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
        result = <span class="hljs-string">''</span>,
        input_len = input.length,
        char_code;

      <span class="hljs-keyword">for</span> ( ; i &lt; input_len; i++ ) {
        char_code = input.charCodeAt( i );

        result +=
          char_code === <span class="hljs-number">34</span> ? <span class="hljs-string">'\\"'</span> : <span class="hljs-comment">// double quote</span>
        char_code === <span class="hljs-number">92</span> ? <span class="hljs-string">'\\\\'</span> : <span class="hljs-comment">// backslash</span>
        <span class="hljs-number">31</span> &lt; char_code &amp;&amp; char_code &lt; <span class="hljs-number">127</span> ? String_fromCharCode( char_code ) : <span class="hljs-comment">// ASCII printables</span>
        char_code === <span class="hljs-number">8</span> ? <span class="hljs-string">'\\b'</span> : <span class="hljs-comment">// backspace</span>
        char_code === <span class="hljs-number">9</span> ? <span class="hljs-string">'\\t'</span> : <span class="hljs-comment">// tab</span>
        char_code === <span class="hljs-number">10</span> ? <span class="hljs-string">'\\n'</span> : <span class="hljs-comment">// new line</span>
        char_code === <span class="hljs-number">12</span> ? <span class="hljs-string">'\\f'</span> : <span class="hljs-comment">// form feed</span>
        char_code === <span class="hljs-number">13</span> ? <span class="hljs-string">'\\r'</span> : <span class="hljs-comment">// carriage return</span>
        (
          char_code &lt; <span class="hljs-number">256</span> ? <span class="hljs-string">'\\x'</span> + ( char_code &lt; <span class="hljs-number">16</span> ? <span class="hljs-string">'0'</span> : <span class="hljs-string">''</span> ) : <span class="hljs-string">'\\u'</span> + ( char_code &lt; <span class="hljs-number">4096</span> ? <span class="hljs-string">'0'</span> : <span class="hljs-string">''</span> )
        ) + char_code.toString( <span class="hljs-number">16</span> );
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">'"'</span> + result + <span class="hljs-string">'"'</span>;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    unquote: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ?
        <span class="hljs-built_in">String</span>( input ).replace( <span class="hljs-regexp">/\\([btnfr"\\])/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( _, esc )</span> {</span>
          <span class="hljs-keyword">return</span> (
            esc === <span class="hljs-string">'b'</span> ? <span class="hljs-string">'\b'</span> : <span class="hljs-comment">// backspace</span>
            esc === <span class="hljs-string">'t'</span> ? <span class="hljs-string">'\t'</span> : <span class="hljs-comment">// tab</span>
            esc === <span class="hljs-string">'n'</span> ? <span class="hljs-string">'\n'</span> : <span class="hljs-comment">// new line</span>
            esc === <span class="hljs-string">'f'</span> ? <span class="hljs-string">'\f'</span> : <span class="hljs-comment">// form feed</span>
            esc === <span class="hljs-string">'r'</span> ? <span class="hljs-string">'\r'</span> : <span class="hljs-comment">// carriage return</span>
            esc <span class="hljs-comment">// backslash and double quote</span>
          )
        } ).replace( <span class="hljs-regexp">/[xu]([0-9A-F]{2})([0-9A-F]{2})?/gi</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( _, x, u )</span> {</span>
          <span class="hljs-keyword">return</span> String_fromCharCode( <span class="hljs-built_in">parseInt</span>( x + ( u || <span class="hljs-string">''</span> ), <span class="hljs-number">16</span> ) );
        } ).slice( <span class="hljs-number">1</span>, -<span class="hljs-number">1</span> ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a number[]</strong><br/>(- an array of char code numbers representing this&#39; string.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    ord: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

      <span class="hljs-keyword">var</span>
      i = input.length,
        result = <span class="hljs-built_in">Array</span>( i );

      <span class="hljs-keyword">while</span> ( i-- ) result[ i ] = input.charCodeAt( i );

      <span class="hljs-keyword">return</span> result;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>prepends the prefixes to this&#39; string in the given order.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>prefix</code> must be a string.</strong><br/>(an arbitrary number of strings to prepend recursivelyin the given order)</li>
</ul>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    prepend: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, prefix )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      <span class="hljs-keyword">return</span> prefix + input;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>comparable</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(strings to compare with)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not this&#39; string strictly equals the string representation of all <code>comparable</code>s)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    isEqual: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, comparable )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>( comparable ) === input;
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a boolean</strong><br/>(- whether the string has length <code>0</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? !<span class="hljs-built_in">String</span>( input ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a boolean</strong><br/>(- whether the string is empty or consists of whitespace only)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    isBlank: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      <span class="hljs-keyword">return</span> !input || !re_no_whitespace.test( input );
    },

    collapseWhitespace: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).replace( re_whitespaces, <span class="hljs-string">' '</span> ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>TODO: support diacritics and ligatures</p>
<p><strong>Returns a string</strong><br/>(- input with first letter upper-cased.)</p>
<p>Example:</p>
<pre><code><span class="hljs-constant">Stryng</span>.capitalize(<span class="hljs-string">'foo'</span>); <span class="hljs-regexp">//</span> yields <span class="hljs-string">"Foo"</span>
</code></pre></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    capitalize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

      <span class="hljs-keyword">var</span> input_len = input.length;

      <span class="hljs-keyword">return</span> ( !input_len ? input :
        input_len === <span class="hljs-number">1</span> ? input.toUpperCase() :
        input.charAt( <span class="hljs-number">0</span> ).toUpperCase() + input.substring( <span class="hljs-number">1</span> )
      );
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>inspired by <a href="http://emberjs.com/api/classes/Ember.String.html#method_camelize">emberjs</a>
note that this leaves the very first letter untouched.
for a classified output compose this method with <em>Stryng#capitalize</em>.</p>
<p><strong>Returns a string</strong><br/>(- this&#39; string transformed into camel case by removing all occurences of space, underscore and hyphen and upper casing the first lower cased letter following those.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    camelize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ?
        <span class="hljs-built_in">String</span>( input )
        .replace( <span class="hljs-regexp">/[ _-]([a-z]?)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( _, character )</span> {</span>
          <span class="hljs-keyword">return</span> character ? character.toUpperCase() : <span class="hljs-string">''</span>;
        } ) : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>inspired by <a href="http://emberjs.com/api/classes/Ember.String.html#method_underscore">emberjs</a></p>
<p><strong>Returns a string</strong><br/>(- this&#39; string transformed into an underscored form by inserting <code>_</code> where upper cased letters follow lower ones, replacing space and hyphen by <code>_</code> and finally lower casing the output.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    underscore: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ?
        <span class="hljs-built_in">String</span>( input )
        .replace( <span class="hljs-regexp">/([a-z])([A-Z])/g</span>, <span class="hljs-string">'$1_$2'</span> )
        .replace( <span class="hljs-regexp">/[ -]/g</span>, <span class="hljs-string">'_'</span> )
        .toLowerCase() : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>inspired by <a href="http://emberjs.com/api/classes/Ember.String.html#method_dasherize">emberjs</a></p>
<p><strong>Returns a string</strong><br/>(- this&#39; string transformed into an underscored form by inserting <code>-</code> where upper cased letters follow lower ones, replacing space and underscore by <code>-</code> and finally lower casing the output.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    dasherize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ?
        <span class="hljs-built_in">String</span>( input )
        .replace( <span class="hljs-regexp">/([a-z])([A-Z])/g</span>, <span class="hljs-string">'$1-$2'</span> )
        .replace( <span class="hljs-regexp">/[ _]/g</span>, <span class="hljs-string">'-'</span> )
        .toLowerCase() : exit();
    },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>replaces ligatures and diacritics from the Latin-1 Supplement
with their nearest plain letter, replaces symbols otherwise being percentescaped.
compose this method with <em>Stryng#dasherize</em> to produce URL slugs</p>
<p><strong>Returns a string</strong><br/>([description])</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    slugify: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
      object_forOwn.call( latin_1_supplement, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( re, nearest_char )</span> {</span>
        input = input.replace( re, nearest_char );
      } );
      <span class="hljs-keyword">return</span> Stryng.dasherize( input );
    }
  };
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="static-functions"><a href="#static-functions" class="anchor"></a>static functions</h2></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>generates a string of random characters which default to the ASCII printables.
to choose randomly from the whole Unicode table call <code>Stryng.random(n, 0, -1)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 0.</strong></li>
<li><strong><code>from</code> is optional, must be a number, and has a default value of 32.</strong><br/>(inclusively)</li>
<li><strong><code>to</code> is optional, must be a number, and has a default value of 127.</strong><br/>(exclusively assuming <em>Math.random</em> never yields <code>1</code>)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- string of length <code>n</code> with characters (ASCII by default) randomly choosen from the Unicode table with code-range [<code>from</code>, <code>to</code>])</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  Stryng.random = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, from, to )</span> {</span>
    <span class="hljs-keyword">if</span> ( n &lt;= -<span class="hljs-number">1</span> || n == INFINITY ) exit();

    n = n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( n ) || <span class="hljs-number">0</span>;
    from = from === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-number">32</span> : ( from &gt;&gt;&gt; <span class="hljs-number">0</span> );
    to = to === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-number">127</span> : ( to &gt;&gt;&gt; <span class="hljs-number">0</span> );

    <span class="hljs-keyword">if</span> ( to &gt; MAX_CHARCODE ) exit();

    <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>,
      diff = to - from;

    <span class="hljs-keyword">if</span> ( diff &gt; <span class="hljs-number">0</span> ) {
      <span class="hljs-keyword">while</span> ( n-- ) {
        result += String_fromCharCode( from + Math_floor( Math_random() * diff ) );
      }
    }

    <span class="hljs-keyword">return</span> result;
  };

  <span class="hljs-keyword">if</span> ( DEBUG ) Stryng.random._name = <span class="hljs-string">'random'</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>delegates to native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">String.fromCharCode</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>charCode</code> must be any number of numbers.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the concatenated string representations of the given <code>charCode</code>s from the UTF-16 table. empty if no arguments passed)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  Stryng.chr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( <span class="hljs-comment">/* charCodes,... */</span>)</span> {</span>
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
      i = args.length;
    <span class="hljs-keyword">while</span> ( i-- )
      <span class="hljs-keyword">if</span> ( args[ i ] &gt; MAX_CHARCODE ) exit(<span class="hljs-string">'char code '</span> + args[ i ] + <span class="hljs-string">' is out of range.'</span>);
    <span class="hljs-keyword">return</span> String_fromCharCode.apply( <span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span> );
  };

  <span class="hljs-keyword">if</span> ( DEBUG ) Stryng.chr._name = <span class="hljs-string">'chr'</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>restores the previous value assigned to <code>window.Stryng</code>.</p>
<p><strong>Returns a Stryng</strong><br/>(- the inner reference <em>Stryng</em> holds to itself)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  Stryng.noConflict = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    window.Stryng = previous_Stryng;
    <span class="hljs-keyword">return</span> Stryng;
  }
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 function Stryng.fromCharCode
</span></p>
<p>delegate directly to native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">String.fromCharCode</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>charCode</code> is optional and must be a number.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- string representation of the given <code>charCode</code>s from the UTF-16 table or the empty string if no arguments passed.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  Stryng.fromCharCode = String_fromCharCode;
  Stryng.fromCodePoint = String_fromCodePoint;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="building-stryng"><a href="#building-stryng" class="anchor"></a>building Stryng</h1></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="custom-methods"><a href="#custom-methods" class="anchor"></a>custom methods</h2><ul>
<li>provide a closure for each wrapper function</li>
<li>in <em>DEBUG</em> mode assign <code>_name</code> property to the function to make
our custom <a href="#exit">exit</a> method work</li>
<li>populate the custom static function <code>fn</code> onto the <em>Stryng</em> namespace</li>
<li>populate the function onto Stryng&#39;s prototype wrapped in another which..</li>
<li>unshifts the <em>Stryng</em> instance&#39;s wrapped <code>_value</code>
to become the first argument among the proxied ones to the static function</li>
<li>decides upon the type of <code>result</code> and whether this <code>_is_mutable</code> what to return.<ul>
<li>if <code>result</code> isn&#39;t a string at all, simply return it</li>
<li>if the instance <code>_is_mutable</code>, assign <code>result</code> to <code>_value</code> and return <code>this</code></li>
<li>if not, return a new instance of <em>Stryng</em> constructed from <code>result</code></li>
</ul>
</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  object_forOwn.call( stryng_members, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( fn, fn_name )</span> {</span>

    <span class="hljs-keyword">if</span> ( DEBUG ) fn._name = fn_name;

    Stryng[ fn_name ] = fn;

    Stryng.prototype[ fn_name ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( <span class="hljs-comment">/* proxied arguments */</span>)</span> {</span>

      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
        result;

      array_unshift.call( args, <span class="hljs-keyword">this</span>._value );
      result = fn.apply( <span class="hljs-literal">null</span>, args );

      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'string'</span> ) { <span class="hljs-comment">// we can rest assured that this is a primitive</span>
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._is_mutable ) {
          <span class="hljs-keyword">this</span>._value = result;
          <span class="hljs-keyword">if</span> ( !Object_defineProperty ) {
            <span class="hljs-keyword">this</span>.length = result.length;
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( result );
        }
      }
      <span class="hljs-keyword">return</span> result;
    };
  } );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="native-methods"><a href="#native-methods" class="anchor"></a>native methods</h2><ul>
<li>provide a closure for each wrapper function</li>
<li>skip functions that need stay shimmed</li>
<li>populate the native static function <code>String[ fn_name ]</code> onto the
<em>Stryng</em> namespace if it exists, otherwise construct one from the equivalent
instance method <code>fn</code> as learned from <a href="http://bonsaiden.github.io/JavaScript-Garden/#function.arguments">javascript garden</a></li>
<li>in <em>DEBUG</em> mode assign <code>_name</code> property to the function to make
our custom <a href="#exit">exit</a> method work</li>
<li>populate the function onto Stryng&#39;s prototype wrapped in another which..</li>
<li>calls the native instance method in the context of the Stryng
instance&#39;s wrapped <code>_value</code></li>
<li>proxies the given <code>arguments</code></li>
<li>decides upon the type of <code>result</code> and whether this <code>_is_mutable</code> what to return.<ul>
<li>if the result isn&#39;t a string at all, simply return it</li>
<li>if the instance <code>_is_mutable</code>, set the value and return <code>this</code></li>
<li>if not, return a new instance of <em>Stryng</em> constructed from the result</li>
</ul>
</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  array_forEach.call( methods, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( fn_name )</span> {</span>

    <span class="hljs-keyword">var</span> fn = string[ fn_name ];

    <span class="hljs-keyword">if</span> ( is.Function( fn ) &amp;&amp; shim_methods.indexOf( fn_name ) === -<span class="hljs-number">1</span> ) {

      Stryng[ fn_name ] = <span class="hljs-built_in">String</span>[ fn_name ] || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
        <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> ) exit();
        <span class="hljs-keyword">return</span> function_call.apply( fn, <span class="hljs-built_in">arguments</span> )
      }

      <span class="hljs-keyword">if</span> ( DEBUG ) Stryng[ fn_name ]._name = fn_name;

      Stryng.prototype[ fn_name ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( <span class="hljs-comment">/* proxied arguments */</span>)</span> {</span>

        <span class="hljs-keyword">var</span> result = fn.apply( <span class="hljs-keyword">this</span>._value, <span class="hljs-built_in">arguments</span> );

        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'string'</span> ) { <span class="hljs-comment">// we can rest assured that this is a primitive</span>
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>._is_mutable ) {
            <span class="hljs-keyword">this</span>._value = result;
            <span class="hljs-keyword">if</span> ( !Object_defineProperty ) {
              <span class="hljs-keyword">this</span>.length = result.length;
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( result );
          }
        }
        <span class="hljs-keyword">return</span> result;
      };
    }
  } );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="seemlessness"><a href="#seemlessness" class="anchor"></a>seemlessness</h2><p>by overriding <code>valueOf</code> and <code>toString</code> on the prototype
chain, instances of <em>Stryng</em> can be used like native ones
in many situations:</p>
<pre><code><span class="hljs-keyword">var</span> numeric = Stryng(<span class="hljs-string">'123'</span>);
!numeric; <span class="hljs-comment">// false</span>
+numeric; <span class="hljs-comment">// 123</span>
<span class="hljs-keyword">var</span> greeting = Stryng(<span class="hljs-string">'Hello'</span>);
greeting + <span class="hljs-string">' World!'</span> <span class="hljs-comment">// 'Hello World'</span>
<span class="hljs-keyword">var</span> dictionary = {};
dictionary[ greeting ] = <span class="hljs-string">'Salut'</span>; <span class="hljs-comment">// {'Hello': 'Salut'}</span>
</code></pre><p>however, there are exceptions to this:</p>
<pre><code><span class="hljs-keyword">var</span> stryng = Stryng();
<span class="hljs-keyword">typeof</span> stryng; <span class="hljs-comment">// 'object'</span>
stryng <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>; <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(stryng); <span class="hljs-comment">// '[object Object]'</span>
</code></pre><p>a viable check is</p>
<pre><code>stryng instanceof <span class="hljs-constant">Stryng</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>
</code></pre><p>but only for as long as <code>stryng</code> was actually constructed using
that specific <code>Stryng</code> constructor and not some other foreign (i)frame&#39;s one.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  Stryng.prototype.valueOf =
    Stryng.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value; <span class="hljs-comment">// we can rest assured that this is a primitive</span>
  }
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="aliases"><a href="#aliases" class="anchor"></a>aliases</h2><p>every function that ends with either <code>Left</code> or <code>Right</code> is
available with prefix <code>l</code> or <code>r</code> respectively instead.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  object_forOwn.call( stryng_members, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( fn, fn_name )</span> {</span>

    <span class="hljs-keyword">var</span> alias = <span class="hljs-keyword">new</span> Stryng( fn_name );

    <span class="hljs-keyword">if</span> ( alias.endsWith( <span class="hljs-string">'Left'</span> ) ) {
      alias = alias.stripRight( <span class="hljs-string">'Left'</span> ).prepend( <span class="hljs-string">'l'</span> );

      Stryng[ alias ] = fn;
      Stryng.prototype[ alias ] = Stryng.prototype[ fn_name ];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( alias.endsWith( <span class="hljs-string">'Right'</span> ) ) {
      alias = alias.stripRight( <span class="hljs-string">'Right'</span> ).prepend( <span class="hljs-string">'r'</span> );

      Stryng[ alias ] = fn;
      Stryng.prototype[ alias ] = Stryng.prototype[ fn_name ];
    }
  } );

  Stryng.shallowStringify = Stryng.quote;
  Stryng.prototype.shallowStringify = Stryng.prototype.quote;

  Stryng.append = Stryng.concat;
  Stryng.prototype.append = Stryng.prototype.concat;

}() );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 callback contribution
</span></p>
<p>Parameters:</p>
<ul>
<li><p><strong><code>input</code> must be a string.</strong><br/>(the string to work on)
{...*}</p>
<p>String literal ( with <code>string instanceOf String</code> yielding false )</p>
</li>
</ul>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script></div>
        </div>
      
      
      </div>
    
    </div>
  </div>

  <script src="../toc.js"></script>
  <script src="../assets/libs.js"></script>
  <script src="../assets/behavior.js"></script>
</body>
</html>