<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> - README.md</title>

  <link rel="stylesheet" href="assets/style.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>
  <meta name="groc-relative-root" content=""/>
  <meta name="groc-document-path" content="README.md"/>
  
</head>
<body>
  <div id="file-area">
    <div id="meta">
      <code class="file-path">
      
        README.md
      
      </code>
    </div>
    <div id="document">
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="stryng"><a href="#stryng" class="anchor"></a>Stryng</h2><p>If the necessity of manipulating strings correctly in JavaScript arises you will find yourself dealing with weird native behaviors, constructing even weirder workarounds to tweak them into being consistent and easy to handle. Stryng manually inherits from the built-in <code>String</code> object, detects and fixes native non-spec compliant implementations, provides polyfills fulfilling ECMA 5 and 6 standards and lastly mixes in its own set of utility functions.</p>
<p><a href="https://ci.testling.com/espretto/Stryng"><img src="https://ci.testling.com/espretto/stryng.png" alt="browser support"></a></p>
<h2 id="let-me-introduce"><a href="#let-me-introduce" class="anchor"></a>Let me introduce</h2><pre><code><span class="hljs-built_in">String</span>.prototype.toStryng = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( <span class="hljs-keyword">this</span> );
};

<span class="hljs-string">'The quick brown fox'</span>.toStryng()
<span class="hljs-comment">// now we are ready you may use</span>
.stripRight( <span class="hljs-string">'fox'</span> )
<span class="hljs-comment">// which leaves us with 'The quick brown ' - chaining on</span>
.truncate( <span class="hljs-number">15</span> )
<span class="hljs-comment">// yields 'The quick...'</span>
.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">1</span>]
.capitalize()
<span class="hljs-comment">// you knew "Quick..." was coming</span>
.count(<span class="hljs-string">'.'</span>)
<span class="hljs-comment">// 3 dots</span>
</code></pre><p>wherever you forget to pass an argument expected to be a string <code>&#39;undefined&#39;</code> - as the result of calling <code>String( undefined )</code> - will be applied as the default. this derives from javascript&#39;s native behaviour.</p>
<pre><code><span class="hljs-string">'undefined'</span>.contains();   <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>
<span class="hljs-string">'undefined'</span>.startsWith(); <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>
<span class="hljs-string">'undefined'</span>.endsWith();   <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>
<span class="hljs-string">'undefined'</span>.indexOf();    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>
<span class="hljs-string">'undefined'</span>.lastIndexOf();<span class="hljs-regexp">//</span> same as the above
<span class="hljs-string">'undefined'</span>.search();     <span class="hljs-regexp">//</span> same as the above again

<span class="hljs-string">'this is yours'</span>.replace(<span class="hljs-string">'yours'</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">'this is undefined'</span>

new <span class="hljs-constant">RegExp</span>().test(<span class="hljs-string">'undefined'</span>); <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>
</code></pre><p>but there are of course exceptions to this</p>
<pre><code><span class="hljs-typename">String</span>(); // the empty <span class="hljs-typename">string</span> instead <span class="hljs-keyword">of</span> <span class="hljs-attribute">'undefined</span>'
<span class="hljs-keyword">new</span> <span class="hljs-typename">String</span>(); // luckily just the same as above
<span class="hljs-attribute">'this</span> <span class="hljs-keyword">is</span> '.concat(); // nothing changes, expected <span class="hljs-attribute">'this</span> <span class="hljs-keyword">is</span> undefined'
</code></pre><p>the last example of the above probably derives from <em>String#concat</em> being the gerenic <em>Array#concat</em>.</p>
<h2 id="documentation"><a href="#documentation" class="anchor"></a>Documentation</h2><p>please refer to either the <a href="http://espretto.github.io/Stryng">api documentation</a>, <a href="http://espretto.github.io/Stryng/grock">grock&#39;s annotated source</a> or <a href="http://espretto.github.io/Stryng/docker/README.md.html">docker&#39;s annotated source</a>.</p>
<h3 id="notes-on-doc-notation"><a href="#notes-on-doc-notation" class="anchor"></a>notes on doc notation</h3><ul>
<li>explain code <em>sections</em> - preferrably with step-by-step lists - instead of annotating every single snippet</li>
<li>use underscored variable names for privates, camel-case for the api.</li>
<li>&quot;this&#39; string&quot; always refers to the string wrapped by Stryng</li>
<li>&quot;returns&quot;, &quot;results to&quot;, &quot;evaluates to&quot; or &quot;yields&quot; - do what you like</li>
<li>unfortunately <em>docker</em>&#39;s markdown parser doesn&#39;t support lists nested deeper than 2 levels</li>
<li>read the annotated source and try to stick to its flavour</li>
</ul>
<h2 id="credits"><a href="#credits" class="anchor"></a>Credits</h2><p>Many thanks to the authors of</p>
<ul>
<li><a href="https://github.com/davidshimjs/jaguarjs-jsdoc">jsdoc template</a></li>
<li><a href="https://github.com/killercup/grock">grock</a></li>
<li><a href="https://github.com/jbt/docker">docker</a></li>
</ul>
<h2 id="roadmap"><a href="#roadmap" class="anchor"></a>Roadmap</h2><ul>
<li>refactor tests</li>
<li>integrate them into docs</li>
<li>renew testling setup</li>
<li>extend with plugin <code>Stryng.esc</code> for encoding conversions related to url parsing and slugifying</li>
</ul>
<h2 id="about-tointeger"><a href="#about-tointeger" class="anchor"></a>About toInteger</h2><p>from the <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.4">spec</a>:</p>
<ol>
<li>let number be the result of calling <code>toNumber</code> on the input argument.</li>
<li>if number is <code>NaN</code>, return <code>+0</code>.</li>
<li>if number is <code>+0</code>, <code>−0</code>, <code>+Infinity</code>, or <code>−Infinity</code>, return number i.e. leave zeros and infinites untouched</li>
<li>Rireturn the result of computing <code>sign(number) × floor(abs(number))</code> i.e. ceil negatives, floor positives</li>
</ol>
<p>in the following scenarios calling <code>Number.toInteger</code> can be replaced with faster inline comparisons:</p>
<h3 id="isnegative"><a href="#isnegative" class="anchor"></a>isNegative</h3><pre><code>var x = -<span class="hljs-number">0</span>.<span class="hljs-number">5</span>;
x &lt; <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> yields <span class="hljs-keyword">true</span>
<span class="hljs-constant">Number_toInteger</span>( x ) &lt; <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> yields <span class="hljs-keyword">false</span> because it ceils negative values <span class="hljs-keyword">and</span> hence compares <span class="hljs-number">0</span> &lt; <span class="hljs-number">0</span>
</code></pre><p>the faster equivalent of the above <code>Number_toInteger</code> call and comparison is</p>
<pre><code><span class="hljs-attribute">x &lt;</span>=<span class="hljs-string"> -1;</span>
</code></pre><h3 id="isnotfinite"><a href="#isnotfinite" class="anchor"></a>isNotFinite</h3><pre><code>Number_toInteger( <span class="hljs-string">'Infinity'</span> ) == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
Number_toInteger( <span class="hljs-literal">Infinity</span> ) == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
Number_toInteger( <span class="hljs-number">1</span>/<span class="hljs-number">0</span> ) == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
</code></pre><p>the above expressions are the only ones evaluated to <code>Infinity</code>.
However, since <code>Number_toInteger</code> uses <code>toNumber</code> internally and simply return
results <code>+0</code>, <code>−0</code>, <code>+Infinity</code> and <code>−Infinity</code> of <code>toNumber</code> you may equally use</p>
<pre><code><span class="hljs-string">'Infinity'</span> == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
<span class="hljs-literal">Infinity</span> == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
<span class="hljs-number">1</span>/<span class="hljs-number">0</span> == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
</code></pre><p>to spare another function call. same goes for <code>-Infinity</code>.</p>
<h3 id="apply-zero-as-minimum"><a href="#apply-zero-as-minimum" class="anchor"></a>apply zero as minimum</h3><p>instead of</p>
<pre><code><span class="hljs-setting">x = <span class="hljs-value">Number_toInteger( x );</span></span>
<span class="hljs-setting">x = <span class="hljs-value">Math.max( <span class="hljs-number">0</span>, x );</span></span>
</code></pre><p>you may equally do</p>
<pre><code><span class="hljs-attribute">x </span>=<span class="hljs-string"> x &lt; 0 ? 0 : Math.floor( x ) || 0;</span>
</code></pre><p>where the last bit zeros <code>NaN</code>.</p>
<p>worth a zealot&#39;s blog post..</p>
</div>
        </div>
      
      
      </div>
    
    </div>
  </div>

  <script src="toc.js"></script>
  <script src="assets/libs.js"></script>
  <script src="assets/behavior.js"></script>
</body>
</html>