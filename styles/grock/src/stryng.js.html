<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>baseline setup - stryng.js</title>

  <link rel="stylesheet" href="../assets/style.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>
  <meta name="groc-relative-root" content="../"/>
  <meta name="groc-document-path" content="src/stryng.js"/>
  
</head>
<body>
  <div id="file-area">
    <div id="meta">
      <code class="file-path">
      
        src/stryng.js
      
      </code>
    </div>
    <div id="document">
    
      <div class="segment">
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>if the necessity of manipulating strings correctly in JavaScript arises
you will find yourself dealing with weird native behaviors,
constructing even weirder workarounds to tweak them into being consistent
and easy to handle. <em>Stryng</em> provides these utility functions.
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_generic_methods">article on generics</a>
lybrary, functyon, obyect, stryng, nymber, javascrypt, array, boolyan</p>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>TODO performance check
function call with passing a reference to a Stryng object or a string primitive</p>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>leverage uglifyjs&#39; ability to declare global variables</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> DEBUG === <span class="hljs-string">'undefined'</span>) DEBUG = <span class="hljs-literal">true</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="baseline-setup"><a href="#baseline-setup" class="anchor"></a>baseline setup</h1></div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-keyword">var</span> <span class="hljs-comment">// one to var them all</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to access native instance methods</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">array, object, string, regex, func,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>current version</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">VERSION = string = <span class="hljs-string">'0.0.1'</span>,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used for input validation</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">INFINITY = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to limit <em>String.fromCharCode</em></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">MAX_CHARCODE = <span class="hljs-number">65535</span>, <span class="hljs-comment">// Math.pow(2, 16) - 1</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used to convert to string</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-built_in">String</span> = func = string.constructor,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>methods <em>Stryng</em> hopes to adopt</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">methods = array = (
+ <span class="hljs-string">'charAt,'</span>
+ <span class="hljs-string">'charCodeAt,'</span>
+ <span class="hljs-string">'codePointAt,'</span>
+ <span class="hljs-string">'concat,'</span>
+ <span class="hljs-string">'contains,'</span>
+ <span class="hljs-string">'endsWith'</span>
+ <span class="hljs-string">'indexOf,'</span>
+ <span class="hljs-string">'lastIndexOf,'</span>
+ <span class="hljs-string">'localeCompare,'</span>
+ <span class="hljs-string">'match,'</span>
+ <span class="hljs-string">'normalize,'</span>
+ <span class="hljs-string">'replace,'</span>
+ <span class="hljs-string">'search,'</span>
+ <span class="hljs-string">'slice,'</span>
+ <span class="hljs-string">'split,'</span>
+ <span class="hljs-string">'startsWith,'</span>
+ <span class="hljs-string">'substr,'</span>
+ <span class="hljs-string">'substring,'</span>
+ <span class="hljs-string">'toLocaleLowerCase,'</span>
+ <span class="hljs-string">'toLocaleUpperCase,'</span>
+ <span class="hljs-string">'toLowerCase,'</span>
+ <span class="hljs-string">'toUpperCase,'</span>
+ <span class="hljs-string">'trim,'</span>
+ <span class="hljs-string">'trimLeft,'</span>
+ <span class="hljs-string">'trimRight'</span>
).split( <span class="hljs-string">','</span> ),
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>methods which&#39;s native implementations to override if necessary</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">shim_methods = [],
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>inner module to hold type/class check functions.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">is = object = {},
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="method-shortcuts"><a href="#method-shortcuts" class="anchor"></a>method shortcuts</h1><p>create quick access variables for both native static functions
and instance methods. polyfills are reduced in functionality and byte-size.
they are thus <strong>for internal use only</strong> and neither populated onto
native prototypes nor intended to be spec-compliant.</p>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="static-methods"><a href="#static-methods" class="anchor"></a>static methods</h2></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">JSON_stringify       = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">JSON</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">JSON</span>.stringify,
Math_floor           = <span class="hljs-built_in">Math</span>.floor,
Math_random          = <span class="hljs-built_in">Math</span>.random,
String_fromCharCode  = <span class="hljs-built_in">String</span>.fromCharCode,
String_fromCodePoint = <span class="hljs-built_in">String</span>.fromCodePoint,

Object_defineProperty = ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( defineProperty )</span> {</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>try to define a dummy property on an object literal which fails<ul>
<li>either in case <code>defineProperty</code> isn&#39;t available</li>
<li>or only DOM objects are allowed as first argument</li>
</ul>
</li>
<li>if successful, return the reference to that function</li>
<li>implicitely return <code>undefined</code> otherwise</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">try</span> {
    defineProperty( {}, string, { value: <span class="hljs-number">1</span> } );
    <span class="hljs-keyword">return</span> defineProperty;
  } <span class="hljs-keyword">catch</span> ( e ) {}

} )( <span class="hljs-built_in">Object</span>.defineProperty ),
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="instance-methods"><a href="#instance-methods" class="anchor"></a>instance methods</h2></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">array_forEach = array.forEach || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( iterator )</span> {</span>
 
  <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">this</span>, i = array.length;

  <span class="hljs-keyword">while</span>( i-- ) iterator( array[ i ] );
},
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>fast forwardly iterate over this.
do not cache <code>this.length</code> since it may change.</li>
<li>let <code>item</code> be this&#39;s element at index <code>i</code></li>
<li>if <code>item</code> is iterable<ul>
<li>unshift the index <code>i</code> and <code>1</code>
to comply with the signature of <em>Array#splice</em></li>
<li>replace the iterable item with its contents ( in situ )</li>
<li>do not increment the index in order to process the first
element of <code>item</code>&#39;s contents in the next iteration</li>
</ul>
</li>
<li>go for the next item otherwise</li>
<li>return <code>this</code> -- mutated</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">array_flatten = array.flatten || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
  
  <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">this</span>, i = <span class="hljs-number">0</span>, item;

  <span class="hljs-keyword">while</span> ( i !== array.length ) {
    item = array[ i ];
    <span class="hljs-keyword">if</span> ( is.Array( item ) ) {
      item.unshift( i, <span class="hljs-number">1</span> );
      array_splice.apply( array, item );
    } <span class="hljs-keyword">else</span> {
      i++;
    }
  }
  <span class="hljs-keyword">return</span> array;
}

array_push      = array.push, <span class="hljs-comment">// faster than `array = array.concat( items )`</span>
array_slice     = array.slice,
array_splice    = array.splice,
array_unshift   = array.unshift,
function_call   = func.call,
object_toString = object.toString,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>make this one pretty for the w3c wishlist.
used in favor of the composition of <em>Array#forEach</em> and <em>Object.keys</em>.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">object_forOwn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( iterator, context )</span> {</span>
  
  <span class="hljs-keyword">var</span> object = <span class="hljs-keyword">this</span>, key, return_value;

  <span class="hljs-keyword">if</span>( object == <span class="hljs-literal">null</span> ){
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'can\'t convert '</span> + object + <span class="hljs-string">' to object'</span>);
  }

  object = <span class="hljs-built_in">Object</span>( object );

  <span class="hljs-keyword">for</span> ( key <span class="hljs-keyword">in</span> object ) {
    <span class="hljs-keyword">if</span> ( object.hasOwnProperty( key ) ) {
      return_value = iterator.call( context, object[ key ], key, object );
      <span class="hljs-keyword">if</span>( return_value === <span class="hljs-literal">false</span> ){
        <span class="hljs-keyword">break</span>;
      }
    }
  }
},
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="regular-expressions"><a href="#regular-expressions" class="anchor"></a>regular expressions</h1></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>used by <a href="#endsWith">Stryng#endsWith</a></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">re_source_matches_end = regex = <span class="hljs-regexp">/[^\\]\$$/</span>,
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="the-whitespace-shim"><a href="#the-whitespace-shim" class="anchor"></a>the whitespace shim</h2><p>native implementations of <em>String#trim</em> might miss out
on some of the more exotic characters considered <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.2">whitespace</a>,
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.3">line terminators</a> or the mysterious <a href="http://www.fileformat.info/info/unicode/category/Zs/list.html">&quot;Zs&quot;</a>.
this section detects those flaws and constructs the regular expressions used
in the polyfills and others - <a href="#splitLines">Stryng#splitLines</a> in particular.
Many thanks to the authors of <a href="http://blog.stevenlevithan.com/archives/faster-trim-javascript">faster trim</a> and <a href="http://perfectionkills.com/whitespace-deviations/">whitespace deviations</a>.</p>
<ul>
<li>let <code>re_whitespace</code> be the native white space matcher.</li>
<li>iterate over our white space characters</li>
<li>add all whitespace characters not recognized
as such to the matcher&#39;s source.</li>
<li>if the native implementation is not <code>is_spec_compliant</code>,
reconstruct the above regular expressions and mark
their associated methods as <em>to be shimmed</em></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">re_no_whitespace = <span class="hljs-regexp">/\S/</span>,
re_trim_left     = <span class="hljs-regexp">/^\s\s*/</span>,
re_trim_right    = <span class="hljs-regexp">/\s*\s$/</span>,
re_linebreaks    = <span class="hljs-regexp">/\n|\r(?!\n)|\u2028|\u2029|\r\n/g</span>;

(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

  <span class="hljs-keyword">var</span>

  is_spec_compliant = <span class="hljs-literal">true</span>,
  re_whitespace = <span class="hljs-regexp">/\s/</span>,
  re_whitespace_source = re_whitespace.source,

  whitespace = (<span class="hljs-string">''</span>
  + <span class="hljs-string">'\t'</span>  <span class="hljs-comment">// '\u0009' tab</span>
  + <span class="hljs-string">'\n'</span>  <span class="hljs-comment">// '\u000A' line feed</span>
  + <span class="hljs-string">'\13'</span> <span class="hljs-comment">// '\u000B' vertical tab</span>
  + <span class="hljs-string">'\f'</span>  <span class="hljs-comment">// '\u000C' form feed</span>
  + <span class="hljs-string">'\r'</span>  <span class="hljs-comment">// '\u000D' carriage return</span>
  + <span class="hljs-string">' '</span>   <span class="hljs-comment">// '\u0020' space</span>

  + <span class="hljs-string">'\xA0'</span> <span class="hljs-comment">// NBSP</span>
  + <span class="hljs-string">'\u1680\u180E\u2000\u2001'</span>
  + <span class="hljs-string">'\u2002\u2003\u2004\u2005'</span>
  + <span class="hljs-string">'\u2006\u2007\u2008\u2009'</span>
  + <span class="hljs-string">'\u200A\u202F\u205F\u3000'</span>

  + <span class="hljs-string">'\u2028'</span> <span class="hljs-comment">// line separator</span>
  + <span class="hljs-string">'\u2029'</span> <span class="hljs-comment">// paragraph separator</span>
  + <span class="hljs-string">'\uFEFF'</span> <span class="hljs-comment">// BOM - byte order mark</span>
  );

  array_forEach.call( whitespace, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( chr )</span> {</span> <span class="hljs-comment">// Array#forEach is generic</span>

    <span class="hljs-keyword">if</span> ( !re_whitespace.test( chr ) ){
      re_whitespace_source += chr;
      is_spec_compliant = <span class="hljs-literal">false</span>;
    }

  } );

  <span class="hljs-keyword">if</span> ( !is_spec_compliant ) {

    shim_methods.push( <span class="hljs-string">'trim'</span>, <span class="hljs-string">'trimRight'</span>, <span class="hljs-string">'trimLeft'</span> );

    re_no_whitespace = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'[^'</span> + re_whitespace_source + <span class="hljs-string">']'</span> );
    re_trim_left     = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'^['</span> + re_whitespace_source + <span class="hljs-string">']['</span> + re_whitespace_source + <span class="hljs-string">']*'</span> );
    re_trim_right    = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'['</span> + re_whitespace_source + <span class="hljs-string">']*['</span> + re_whitespace_source + <span class="hljs-string">']$'</span> );
  }

}());
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="the-substr-check"><a href="#the-substr-check" class="anchor"></a>the <code>substr</code> check</h2><p>check to see if the native implementation
correctly deals with negative indices.
mark as <em>to be shimmed</em> if it doesn&#39;t.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-keyword">if</span> ( <span class="hljs-string">'xy'</span>.substr( -<span class="hljs-number">1</span> ) !== <span class="hljs-string">'y'</span> ) shim_methods.push( <span class="hljs-string">'substr'</span> );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="type-safety"><a href="#type-safety" class="anchor"></a>type safety</h1><p>the inner module <code>is</code> holds type checks. this is an excerpt from
my <a href="https://gist.github.com/esnippo/9960508">gist</a> inspired by the
<a href="http://jquery.com">jQuery</a> and <a href="http://underscorejs.org">underscore</a> libraries.</p>
<ul>
<li>provide quick access to precomputed <code>repr</code> within <em>Array#forEach</em> closure</li>
<li>early exit on &quot;falsies&quot;</li>
<li>apply native implementations where available</li>
<li>fix old webkit&#39;s bug where <code>typeof regex</code> yields <code>&#39;function&#39;</code> </li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">array_forEach.call( [ <span class="hljs-string">'Array'</span>, <span class="hljs-string">'Function'</span>, <span class="hljs-string">'RegExp'</span> ], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( klass )</span> {</span>

  <span class="hljs-keyword">var</span> repr = <span class="hljs-string">'[object '</span> + klass + <span class="hljs-string">']'</span>;
  is[ klass ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( any )</span> {</span>
    <span class="hljs-keyword">return</span> any &amp;&amp; object_toString.call( any ) === repr;
  };

} );

is.Array = <span class="hljs-built_in">Array</span>.isArray || is.Array;

<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> regex === <span class="hljs-string">'object'</span> ) {
  is.Function = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( any )</span> {</span>
    <span class="hljs-keyword">return</span> any &amp;&amp; <span class="hljs-keyword">typeof</span> any === <span class="hljs-string">'function'</span>;
  };
}
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="utility-functions"><a href="#utility-functions" class="anchor"></a>utility functions</h1><h2 id="tointeger"><a href="#tointeger" class="anchor"></a>toInteger</h2><p>fully <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.4">spec</a> compliant
implementation of <code>toInteger</code>, tested and benchmarked at <a href="http://jsperf.com/to-integer/11">jsperf</a>.</p>
<ol>
<li>let number be the result of calling <code>toNumber</code> on the input argument.</li>
<li>if number is <code>NaN</code>, return <code>+0</code>.</li>
<li>if number is <code>+0</code>, <code>−0</code>, <code>+Infinity</code>, or <code>−Infinity</code>, return number i.e. leave zeros and infinites untouched</li>
<li>Rireturn the result of computing <code>sign(number) × floor(abs(number))</code> i.e. ceil negatives, floor positives
in the following scenarios calling <code>toInteger</code> can be replaced with faster inline comparisons:<h3 id="isnegative"><a href="#isnegative" class="anchor"></a>isNegative</h3><pre><code>var x = -<span class="hljs-number">0</span>.<span class="hljs-number">5</span>;
x &lt; <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> yields <span class="hljs-keyword">true</span>
toInteger( x ) &lt; <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> yields <span class="hljs-keyword">false</span> because it ceils negative values <span class="hljs-keyword">and</span> hence compares <span class="hljs-number">0</span> &lt; <span class="hljs-number">0</span>
</code></pre>the faster equivalent of the above <code>toInteger</code> call and comparison is<pre><code><span class="hljs-attribute">x &lt;</span>=<span class="hljs-string"> -1;</span>
</code></pre><h3 id="isnotfinite"><a href="#isnotfinite" class="anchor"></a>isNotFinite</h3><pre><code>toInteger( <span class="hljs-string">'Infinity'</span> ) == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
toInteger( <span class="hljs-literal">Infinity</span> ) == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
toInteger( <span class="hljs-number">1</span>/<span class="hljs-number">0</span> ) == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
</code></pre>the above expressions are the only ones evaluated to <code>Infinity</code>.
However, since <code>toInteger</code> uses <code>toNumber</code> internally and simply returns
results <code>+0</code>, <code>−0</code>, <code>+Infinity</code> and <code>−Infinity</code> of <code>toNumber</code> you may equally use<pre><code><span class="hljs-string">'Infinity'</span> == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
<span class="hljs-literal">Infinity</span> == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
<span class="hljs-number">1</span>/<span class="hljs-number">0</span> == <span class="hljs-literal">Infinity</span>; <span class="hljs-comment">// true</span>
</code></pre>to spare another function call. same goes for <code>-Infinity</code>.<h3 id="apply-zero-as-minimum"><a href="#apply-zero-as-minimum" class="anchor"></a>apply zero as minimum</h3>instead of<pre><code><span class="hljs-setting">x = <span class="hljs-value">toInteger( x );</span></span>
<span class="hljs-setting">x = <span class="hljs-value">Math.min( <span class="hljs-number">0</span>, x );</span></span>
</code></pre>you may equally do<pre><code><span class="hljs-attribute">x </span>=<span class="hljs-string"> x &lt; 0 ? 0 : Math.floor( x ) || 0;</span>
</code></pre>where the last bit zeros <code>NaN</code>.
worth a zealot&#39;s blog post..</li>
</ol>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toInteger</span><span class="hljs-params">( any )</span> {</span>
  <span class="hljs-keyword">return</span> (
    ( n = +n ) &amp;&amp; <span class="hljs-built_in">isFinite</span>( n ) <span class="hljs-comment">// toNumber and isFinite</span>
    ? n - ( n % <span class="hljs-number">1</span> ) <span class="hljs-comment">// ceil negatives, floor positives</span>
    : n || <span class="hljs-number">0</span> <span class="hljs-comment">// leave be +-Infinity, translate NaN to zero</span>
  );
}
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="exit"><a href="#exit" class="anchor"></a>exit</h2><p>wraps the process of throwing an <em>Error</em>.
in <em>DEBUG</em> mode composes the error&#39;s message
of the custom <em>Stryng</em> function&#39;s <code>_name</code> property
and the arguments passed i.e. logs the stacktrace of the level above.</p>
<ul>
<li>get the <code>caller</code> function</li>
<li>stringify its arguments</li>
<li>throw the error with the custom message</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exit</span><span class="hljs-params">( message )</span> {</span>
  <span class="hljs-keyword">if</span>( DEBUG ){

    <span class="hljs-keyword">var</span>
      args    = <span class="hljs-string">''</span>,
      caller  = <span class="hljs-built_in">arguments</span>.callee.caller,
      message = <span class="hljs-string">'invalid usage of Stryng.'</span> + caller._name + <span class="hljs-string">'() with args ['</span>;

    array_forEach.call( caller.arguments, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arg )</span> {</span> args += arg + <span class="hljs-string">', '</span> } );

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( message + ( args ? args.slice( <span class="hljs-number">0</span>, -<span class="hljs-number">2</span> ) : <span class="hljs-string">''</span> ) + <span class="hljs-string">']. '</span> + ( message || <span class="hljs-string">''</span> ) );

  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">'invalid usage of Stryng member. '</span> + (message || <span class="hljs-string">''</span>) );
  }
}
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="class-constructor"><a href="#class-constructor" class="anchor"></a>class constructor</h1></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 class Stryng
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>value</code> is optional, must be a *, and has a default value of &quot;&quot;.</strong><br/>(the value to parse. defaults to the empty string)</li>
<li><strong><code>is_mutable</code> is optional, must be a boolean, and has a default value of false.</strong><br/>(whether the created instance should be mutable or create a new instance from the result of every method call)</li>
</ul>
<p><strong>Returns a Stryng</strong><br/>(- the <code>input</code>&#39;s string representation wrapped in the instance returned.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stryng</span><span class="hljs-params">( value , is_mutable )</span> {</span>
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>allow omitting the new operator</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">if</span> ( !( <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Stryng ) ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( value );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 name Stryng~<em>value and of type _string</em>
</span></p>
<p>the wrapped native string primitive</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">this</span>._value = value != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( value ) : <span class="hljs-string">''</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 name Stryng~<em>isMutable and of type _boolean</em>
</span></p>
<p>whether the created instance should be mutable or
create a new instance from the result of every method call</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">this</span>._isMutable = !!is_mutable;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 name Stryng#length and of type <em>number</em>
</span></p>
<p>the <a href="#_value">String#_value</a>&#39;s length defined via <em>Object.defineProperty</em>
if available, simply set onto the instance otherwise.</p>
<p>TODO: further <a href="http://www.2ality.com/2012/08/property-definition-assignment.html">reading</a></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  <span class="hljs-keyword">if</span> ( Object_defineProperty ) {
    Object_defineProperty( <span class="hljs-keyword">this</span>, <span class="hljs-string">'length'</span>, {
      enumerable: <span class="hljs-literal">false</span>,
      configurable: <span class="hljs-literal">false</span>,
      get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value.length
      }
    } );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.length = <span class="hljs-keyword">this</span>._value.length;
  }
}
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><h1 id="cloning-mutables"><a href="#cloning-mutables" class="anchor"></a>cloning mutables</h1><p>in case the instance was not constructed to be mutable
this is the hook to get a copy of it. delegates to <a href="#Stryng">Stryng#constructor</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>is_mutable</code> is optional, must be a boolean, and has a default value of false.</strong><br/>(whether the cloned instance should be mutable or create a new instance from the result of every method call)</li>
</ul>
<p><strong>Returns a Stryng</strong><br/>(- a copy of the <em>Stryng</em> instance)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">Stryng.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( is_mutable )</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( <span class="hljs-keyword">this</span>._value, is_mutable );
};
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="instance-amp-static-functions"><a href="#instance-amp-static-functions" class="anchor"></a>instance &amp; static functions</h1><p>the herein defined methods will be available as both
static functions on the <code>Stryng</code> namespace and instance methods
of the <code>Stryng</code> class. they are declared as static but <strong>documented as
instance methods</strong>, which makes it a lot shorter, less verbose and
easier to highlight the fact that all instance methods are availabe
as static ones but <strong>not vice versa</strong>. the one exception to this is <a href="#clone">Stryng#clone</a>
which only licves on <em>Stryng</em>&#39;s prototype.</p>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 lends Stryng.prototype
</span></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper"><span class="hljs-keyword">var</span> stryng_members = {
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>TODO: support diacritics and ligatures</p>
<p><strong>Returns a string</strong><br/>(- input with first letter upper-cased.)</p>
<p>Example:</p>
<pre><code><span class="hljs-constant">Stryng</span>.capitalize(<span class="hljs-string">'foo'</span>); <span class="hljs-regexp">//</span> yields <span class="hljs-string">"Foo"</span>
</code></pre></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  capitalize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    <span class="hljs-keyword">var</span> length = input.length;

    <span class="hljs-keyword">return</span> (
      !length ? input :
      length === <span class="hljs-number">1</span> ? input.toUpperCase() :
      input.charAt( <span class="hljs-number">0</span> ).toUpperCase() + input.substring( <span class="hljs-number">1</span> )
    );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.20">String#trim</a></p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  trim: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ?
      <span class="hljs-built_in">String</span>( input )
      .replace( reTrimLeft, <span class="hljs-string">''</span> )
      .replace( reTrimRight, <span class="hljs-string">''</span> ) : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for non-standard <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/TrimLeft">String#trimLeft</a></p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  trimLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).replace( reTrimLeft, <span class="hljs-string">''</span> ) : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for non-standard <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/TrimRight">String#trimRight</a></p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  trimRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).replace( reTrimRight, <span class="hljs-string">''</span> ) : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains">String#contains</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>searchString</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>index</code> is optional, must be a number, and has a default value of 0.</strong><br/>(the index to start searching)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not <code>input</code> contains the substring <code>searchString</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  contains: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, searchString, start )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).indexOf( searchString, start ) !== -<span class="hljs-number">1</span> : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.startswith">String#startsWith</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>searchString</code> is optional, can be a string or a RegExp, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>position</code> is optional, must be a number, and has a default value of 0.</strong></li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not <code>input</code> at index <code>position</code> begins with substring <code>searchString</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  startsWith: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, searchString, position )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>if <code>searchString</code> is a regular expression,
return whether or not it matches the beginning of
this&#39; string starting at <code>position</code>.</li>
<li>let <code>i</code> be the index returned by <em>String#indexOf</em>.
let <code>position</code> and <code>searchString</code> be parsed correctly internally</li>
<li>return <code>false</code> if not found i.e. <code>i === -1</code></li>
<li>let <code>input_len</code> be this&#39; string&#39;s length</li>
<li>parse the <code>position</code> argument by the following rules<ul>
<li>default and min to zero</li>
<li>max to <code>input_len</code></li>
<li>floor if positive parsable, zero if <code>NaN</code></li>
</ul>
</li>
<li>return whether or not <code>i</code> equals the above&#39;s result</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span>( is.RegExp( searchString ) ){
      <span class="hljs-keyword">return</span> !input.substring( position ).search( searchString );
    }

    <span class="hljs-keyword">var</span> i = input.indexOf( searchString, position ), input_len;

    <span class="hljs-keyword">if</span> ( i === -<span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    input_len = input.length;
    <span class="hljs-keyword">return</span> i === (
      position === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> || position &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> :
      position &gt; input_len ? input_len :
      Math_floor( position ) || <span class="hljs-number">0</span>
    );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.endswith">String#endsWith</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>searchString</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>endPosition</code> is optional, must be a number, and has a default value of input.length.</strong></li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not <code>input</code> truncated by <code>endPosition</code> ends with substring <code>searchString</code>.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  endsWith: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, searchString, endPosition )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>let <code>input_len</code> be this&#39; string&#39;s length</li>
<li>parse the <code>endPosition</code> argument by the following rules<ul>
<li>default and max to <code>input_len</code></li>
<li>min to zero</li>
<li>floor if parsable, zero if <code>NaN</code></li>
</ul>
</li>
<li>if <code>searchString</code> is a regular expression<ul>
<li>throw an error if the regular expression does not match the
end of its input i.e. does not end with <code>&#39;$&#39;</code></li>
<li>truncate this&#39; string at <code>endPosition</code></li>
<li>return whether or not <code>searchString</code> matches the above&#39;s result</li>
</ul>
</li>
<li>let <code>i</code> be the index returned by <em>String#lastIndexOf</em>.
let <code>position</code> and <code>searchString</code> be parsed correctly internally</li>
<li>return <code>false</code> if not found i.e. <code>i === -1</code></li>
<li>parse the <code>endPosition</code> argument as described above</li>
<li>return whether or not <code>i</code> equals the above&#39;s result</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">var</span>
      input_len = input.length, i,
      endPosition = (
        endPosition === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> || endPosition &gt; input_len ? input_len :
        endPosition &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> :
        Math_floor( endPosition ) || <span class="hljs-number">0</span>
      );

    <span class="hljs-keyword">if</span>( is.RegExp( searchString ) ){
      
      <span class="hljs-keyword">var</span> re_source = searchString.source;
      <span class="hljs-keyword">if</span>( !re_source_matches_end.test( re_source ) ){
        exit(<span class="hljs-string">'"searchString" must match end i.e. end with "$"'</span>);
      }

      <span class="hljs-keyword">return</span> searchString.test( input.substring( <span class="hljs-number">0</span>, endPosition ) );
    }

    searchString = <span class="hljs-built_in">String</span>( searchString );

    <span class="hljs-keyword">if</span> ( !searchString ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    i = input.lastIndexOf( searchString, endPosition );
      
    <span class="hljs-keyword">return</span> i !== -<span class="hljs-number">1</span> &amp;&amp; ( i + searchString.length === endPosition );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.repeat">String#repeat</a>.
reduction of concat operations inspired by <a href="https://github.com/mout/mout/blob/v0.9.0/src/string/repeat.js">mout/string/repeat</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 0.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- this&#39; string <code>n</code> times concatenated to the empty string.)<br/><strong>and</strong> If <code>toInteger( n )</code> is either negative or infinite.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  repeat: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, n )</span> {</span>
    <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || n &lt;= -<span class="hljs-number">1</span> || n == INFINITY ) exit();
    
    n = n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( n ) || <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">while</span> ( n ) {
      <span class="hljs-keyword">if</span> ( n % <span class="hljs-number">2</span> ) {
        result += input;
      }
      n = Math_floor( n / <span class="hljs-number">2</span> );
      input += input;
    }
    <span class="hljs-keyword">return</span> result;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>shim for native <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.substr">String#substr</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>start</code> is optional, must be a number, and has a default value of 0.</strong></li>
<li><strong><code>length</code> must be a number and has a default value of this&#39;.</strong><br/>(length - start])</li>
</ul>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  substr: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, start, length )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse the <code>start</code> argument.<ul>
<li>if <code>toInteger( start )</code> is negative, add <code>input.length</code></li>
<li>if it still is negative, set to zero</li>
</ul>
</li>
<li>leave it up to <code>substr</code>&#39;s implicit parsing any otherwise</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    start = (
      start &lt;= -<span class="hljs-number">1</span> <span class="hljs-comment">// same as `toInteger( start ) &lt; 0`</span>
      ? ( start = toInteger( start ) + input.length ) &lt; <span class="hljs-number">0</span>
      ? <span class="hljs-number">0</span>
      : start
      : start
    );
    
    <span class="hljs-keyword">return</span> input.substr( start, length );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 requires Stryng#repeat
</span></p>
<p>prepends and appends <code>outfix</code> to <code>input</code> in one go.
to do the opposite use <a href="#strip">Stryng.strip</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>outfix</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(prefix and suffix)</li>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 0.</strong><br/>(number of operations)</li>
</ul>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  wrap: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, outfix, n )</span> {</span>
    <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> ) exit();</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>outfix</code> and <code>n</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    outfix = Stryng.repeat( outfix, n );
    <span class="hljs-keyword">return</span> outfix + input + outfix;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>searchString</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(substring to search for)</li>
</ul>
<p><strong>Returns a number</strong><br/>(- number of non-overlapping occurrences of <code>searchString</code> within <code>input</code>. the empty string is considered a <em>character boundary</em> thus <code>input.length + 1</code> will always be the result for that.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  count: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, searchString )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    searchString = <span class="hljs-built_in">String</span>( searchString );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty searchString</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( !searchString ) <span class="hljs-keyword">return</span> input.length + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">var</span>
      length = searchString.length,
      count  = <span class="hljs-number">0</span>,
      i      = -length; <span class="hljs-comment">// prepare first run</span>

    <span class="hljs-keyword">do</span> i = input.indexOf( searchString, i + length );
    <span class="hljs-keyword">while</span> ( i !== -<span class="hljs-number">1</span> &amp;&amp; ++count )

    <span class="hljs-keyword">return</span> count;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>delegates to <em>Arrray#join</em>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>joinees</code> is optional, can be a (...<em> or an Array.&lt;</em>&gt;), and has a default value of [.</strong><br/>(] , nestable)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- <code>joinees</code> joined by native <code>Array.prototype.join</code>. returns the empty string if no second, third .. argument is passed)</p>
<p>Example:</p>
<pre><code>Stryng.join(<span class="hljs-string">' '</span>, <span class="hljs-operator">the</span><span class="hljs-string">', ['</span>quick<span class="hljs-string">', ['</span>brown<span class="hljs-string">', ['</span>fox<span class="hljs-string">']]]); // yeilds '</span><span class="hljs-operator">the</span> quick brown fox<span class="hljs-string">'</span>
</code></pre></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  join: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( delimiter <span class="hljs-comment">/*, strings... */</span> )</span> {</span>
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>; <span class="hljs-comment">// promote compression</span>

    <span class="hljs-keyword">if</span> ( delimiter == <span class="hljs-literal">null</span> ) exit();
    <span class="hljs-keyword">if</span> ( args.length === <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;

    <span class="hljs-keyword">return</span> array_flatten.call( array_slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span> ) ).join( delimiter );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 deprecated <a href="https://github.com/mathiasbynens/esrever">https://github.com/mathiasbynens/esrever</a>
</span></p>
<p><strong>Returns a string</strong><br/>(- the reversed string. usefull yet unefficient to verify palindroms.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  reverse: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input )
      .split( <span class="hljs-string">''</span> )
      .reverse()
      .join( <span class="hljs-string">''</span> ) : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>position</code> is optional, must be a number, and has a default value of 0.</strong><br/>(index of insertion, can be negative)</li>
<li><strong><code>insertion</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> split at <code>position</code> and rejoined using <code>insertion</code> as the delimiter)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  insert: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, position, insertion )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>slice&#39;s native parsing will apply different
defaults for <code>undefined</code> to the first and second argument</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span>( position === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ) position = toInteger( position );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>insertion</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">return</span> input.slice( <span class="hljs-number">0</span>, position ) + insertion + input.slice( position );
  },


  iterate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, delimiter, iterator, context )</span>{</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
    
    <span class="hljs-keyword">var</span>
      delimiter_len,
      rest = input,
      matches,
      match,
      groups = <span class="hljs-literal">null</span>,
      preceding,
      index,
      lastIndex = <span class="hljs-number">0</span>,
      global_index = <span class="hljs-number">0</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>let <code>rest</code> be this&#39;s string</li>
<li>try to find/match argument <code>delimiter</code> in/on <code>rest</code></li>
<li>let <code>match</code> either be the <code>delimiter</code> or the
substring matched by the regular expression</li>
<li>if found, call argument <code>iterator</code> within the context
of argument <code>context</code> and pass arguments<ul>
<li>the substring of this&#39; string preceding <code>match</code></li>
<li><code>match</code> itself</li>
<li>the captured groups if any, null otherwise</li>
<li><code>match</code>&#39;s start index</li>
<li>the substring of this&#39; string following <code>match</code></li>
</ul>
</li>
<li>otherwise let <code>lastIndex</code> be <code>match</code>&#39;s start index plus <code>match</code>&#39;s length
and front-cut <code>rest</code> by that.</li>
<li>if not found call argument <code>iterator</code> within the context
of argument <code>context</code> and pass arguments
[<code>rest</code>, <code>null</code>, <code>null</code>, <code>-1</code>, <code>&#39;&#39;</code>]</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    
    <span class="hljs-keyword">if</span> ( is.RegExp( delimiter ) ) {

      <span class="hljs-keyword">while</span>( matches = rest.match( delimiter ) ){
        global_index += lastIndex;
        
        index     = matches.index;
        preceding = rest.substring( <span class="hljs-number">0</span>, index );
        match     = matches.shift();
        groups    = matches.length ? matches : <span class="hljs-literal">null</span>;
        lastIndex = index + match.length;
        <span class="hljs-keyword">if</span> ( lastIndex &lt;= index ) lastIndex = index + <span class="hljs-number">1</span>;
        rest = rest.substring( lastIndex );
        
        <span class="hljs-keyword">if</span> ( <span class="hljs-literal">false</span> === iterator.call( context, preceding, match, groups, global_index, rest )) <span class="hljs-keyword">break</span>;
      }

    } <span class="hljs-keyword">else</span> {

      delimiter     = <span class="hljs-built_in">String</span>( delimiter );
      delimiter_len = delimiter.length;

      <span class="hljs-keyword">while</span> ( ( index = rest.indexOf( delimiter ) ) !== -<span class="hljs-number">1</span> ){
        global_index += lastIndex;
        
        preceding = rest.substring( <span class="hljs-number">0</span>, index );
        lastIndex = index + delimiter_len;
        match     = rest.substring( index, lastIndex );
        <span class="hljs-keyword">if</span> ( lastIndex &lt;= index ) lastIndex = index + <span class="hljs-number">1</span>;
        rest = rest.substring( lastIndex );

        <span class="hljs-keyword">if</span> ( <span class="hljs-literal">false</span> === iterator.call( context, preceding, match, groups, global_index, rest )) <span class="hljs-keyword">break</span>;
      }
    }
    iterator.call( context, rest, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-string">''</span> );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>delimiter</code> is optional, can be a string or a RegExp, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>n</code> must be a number and has a default value of &lt;Math.pow(2,.</strong><br/>(32) - 1&gt;] maximum number of split operations. as per <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.14">ecma-262/5.1</a>)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- the <code>input</code> split by the given <code>delimiter</code> with anything past the <code>n</code>th occurrence of <code>delimiter</code> untouched yet included in the array.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  splitLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, delimiter, n )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>return the empty array if <code>n</code> is zero</li>
<li>let <code>result</code> be the array to return</li>
<li>if <code>delimiter</code> is a regular expression<ul>
<li>extract <code>n</code> matches using <em>String#match</em> combined with
subsequently front-cutting this&#39; string. using <em>RegExp#exec</em>
would require the regex&#39;s <em>global</em> flag to be set.</li>
<li>push the substrings between the matches and any captured groups to <code>result</code></li>
</ul>
</li>
<li>otherwise let <code>result</code> be the result of <em>String#split</em>
called on this&#39; string with <code>delimiter</code></li>
<li>if argument <code>n</code> is lesser than <code>result.length</code><ul>
<li>remove the last <code>result.length - n</code> items from <code>result</code></li>
<li>rejoin them using <code>delimiter</code></li>
<li>push them to <code>result</code> as one</li>
</ul>
</li>
<li>return <code>result</code></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> ( !n ) <span class="hljs-keyword">return</span> [];

    <span class="hljs-keyword">var</span> result = [],
      match,
      index,
      lastIndex = <span class="hljs-number">0</span>,
      diff;

    <span class="hljs-keyword">if</span> ( is.RegExp( delimiter ) ) {
      <span class="hljs-keyword">while</span> ( n-- &amp;&amp; ( match = input.match( delimiter ))){
        index = match.index;
        result.push( input.substring( <span class="hljs-number">0</span>, index ) );
        lastIndex = index + match.shift().length; <span class="hljs-comment">// mutates `match`</span>
        <span class="hljs-keyword">if</span> ( lastIndex &lt;= lastIndex ) lastIndex = index + <span class="hljs-number">1</span>; <span class="hljs-comment">// avoid endless loop</span>
        <span class="hljs-keyword">if</span> ( match.length ) array_push.apply( result, match ); <span class="hljs-comment">// mutate instead of recreate as concat would</span>
        input = input.substring( lastIndex );
      }
      result.push( input ); <span class="hljs-comment">// push what's left</span>
    } <span class="hljs-keyword">else</span> {
      result = input.split( delimiter );
      diff = result.length - n;
      <span class="hljs-keyword">if</span> ( diff &gt; <span class="hljs-number">0</span> ) {
        result.push( result.splice( n, diff ).join( delimiter ) ); <span class="hljs-comment">// implies parsing delimiter</span>
      }
    }

    <span class="hljs-keyword">return</span> result;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>the right-associative version of <a href="#splitLeft">Stryng.splitLeft</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>delimiter</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] maximum number of split operations. defaults to the number of non-overlapping occurrences of <code>delimiter</code>)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- the <code>input</code> split by the given <code>delimiter</code> with anything in front of the <code>n</code>th occurrence of <code>delimiter</code> - counting backwards - untouched yet included in the array.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  splitRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, delimiter, n )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>return the empty array if <code>n</code> is zero</li>
<li>let <code>result</code> be the result of <em>String#split</em>
called on this&#39; string with <code>delimiter</code></li>
<li>if argument <code>n</code> is lesser than <code>result.length</code><ul>
<li>remove the first <code>n</code> items from <code>result</code></li>
<li>rejoin them using <code>delimiter</code></li>
<li>unshift them to <code>result</code> as one</li>
</ul>
</li>
<li>return <code>result</code></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    
    n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> ( !n ) <span class="hljs-keyword">return</span> [];

    <span class="hljs-keyword">var</span> result = input.split( delimiter ),
      diff = result.length - n;

    <span class="hljs-keyword">if</span> ( diff &gt; <span class="hljs-number">0</span> ) {
      result.unshift( result.splice( <span class="hljs-number">0</span>, diff ).join( delimiter ) );
    }

    <span class="hljs-keyword">return</span> result;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.3">http://www.ecma-international.org/ecma-262/5.1/#sec-7.3</a>
</span></p>
<p><strong>Returns a string[]</strong><br/>(- <code>input</code> split by line-terminators as defined within the spec)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  splitLines: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).split( re_linebreaks ) : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng#splitLeft
</span></p>
<p>implementation of UNIX&#39;s head command</p>
<p>Parameters:</p>
<ul>
<li><strong><code>n</code> must be a number.</strong><br/>(number of lines to return)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- <code>n</code> lines split from the beginning of this&#39; string)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  head: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, n )</span>{</span></pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>input</code> and <code>n</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">return</span> Stryng.splitLeft( input, re_linebreaks, n );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng#splitRight
</span></p>
<p>implementation of UNIX&#39;s tail command</p>
<p>Parameters:</p>
<ul>
<li><strong><code>n</code> must be a number.</strong><br/>(number of lines to return)</li>
</ul>
<p><strong>Returns a string[]</strong><br/>(- <code>n</code> lines split from the beginning of this&#39; string)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  tail: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, n )</span>{</span></pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>input</code> and <code>n</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">return</span> Stryng.splitRight( input, re_linebreaks, n );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>replacee</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to replace)</li>
<li><strong><code>replacement</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(replacement)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> with all non-overlapping occurrences of <code>replacee</code> replaced by <code>replacement</code>.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  exchange: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, replacee, replacement )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    replacee = <span class="hljs-built_in">String</span>( replacee );
    replacement = <span class="hljs-built_in">String</span>( replacement );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for equality</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( replacee === replacement ) <span class="hljs-keyword">return</span> input;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">return</span> input.split( replacee ).join( replacement );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng#exchangeRight
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>replacee</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to replace)</li>
<li><strong><code>replacement</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(replacement)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of replacement operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- this&#39; string with <code>n</code> left-hand non-overlapping occurrences of <code>replacee</code> replaced by <code>replacement</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  exchangeLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, replacee, replacement, n )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
    replacee = <span class="hljs-built_in">String</span>( replacee );
    replacement = <span class="hljs-built_in">String</span>( replacement );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for equality</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( replacee === replacement ) <span class="hljs-keyword">return</span> input;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">return</span> Stryng.splitLeft( input, replacee, n ).join( replacement );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng.exchangeLeft, Stryng.exchange
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>replacee</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to replace)</li>
<li><strong><code>replacement</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(replacement)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of replacement operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> with <code>n</code> right-hand non-overlapping occurrences of <code>replacee</code> replaced by <code>replacement</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  exchangeRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, replacee, replacement, n )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
    replacee = <span class="hljs-built_in">String</span>( replacee );
    replacement = <span class="hljs-built_in">String</span>( replacement );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for equality</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( replacee === replacement ) <span class="hljs-keyword">return</span> input;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">return</span> Stryng.splitRight( input, replacee, n ).join( replacement );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng#justRight, Stryng#just
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>maxLength</code> must be a number.</strong></li>
<li><strong><code>padding</code> must be a string.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> with <code>padding</code> prepended as often as needed for <code>input</code> to reach but not exceed a length of <code>maxLength</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  justLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, maxLength, padding )</span> {</span>
    <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || maxLength &lt;= -<span class="hljs-number">1</span> || maxLength == INFINITY ) exit();

    input = <span class="hljs-built_in">String</span>( input );
    padding = <span class="hljs-built_in">String</span>( padding );
    maxLength = toInteger( maxLength );

    <span class="hljs-keyword">var</span> iLength = input.length;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty padding</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( maxLength &lt;= iLength || !padding ) <span class="hljs-keyword">return</span> input;

    <span class="hljs-keyword">var</span> pLength = padding.length;

    <span class="hljs-keyword">while</span> ( input.length + pLength &lt;= maxLength ) {
      input = padding + input;
    }

    <span class="hljs-keyword">return</span> input;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng.justLeft, Stryng.just
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>maxLength</code> must be a number.</strong></li>
<li><strong><code>padding</code> must be a string.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(the <code>input</code> with <code>padding</code> appended as often as needed for <code>input</code> to reach but not exceed a length of <code>maxLength</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  justRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, maxLength, padding )</span> {</span>
    <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || maxLength &lt;= -<span class="hljs-number">1</span> || maxLength == INFINITY ) exit();

    input = <span class="hljs-built_in">String</span>( input );
    padding = <span class="hljs-built_in">String</span>( padding );
    maxLength = toInteger( maxLength );

    <span class="hljs-keyword">var</span> iLength = input.length;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty padding</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( maxLength &lt;= iLength || !padding ) <span class="hljs-keyword">return</span> input;

    <span class="hljs-keyword">var</span> pLength = padding.length;

    <span class="hljs-keyword">while</span> ( input.length + pLength &lt;= maxLength ) {
      input += padding;
    }

    <span class="hljs-keyword">return</span> input;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 see Stryng.justLeft, Stryng.justRight
</span></p>
<p>Parameters:</p>
<ul>
<li><strong><code>maxLength</code> must be a number.</strong></li>
<li><strong><code>padding</code> must be a string.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(the <code>input</code> with <code>padding</code> appended as often as needed for <code>input</code> to reach but not exceed a length of <code>maxLength</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  just: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, maxLength, padding )</span> {</span>
    <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || maxLength &lt;= -<span class="hljs-number">1</span> || maxLength == INFINITY ) exit();

    input = <span class="hljs-built_in">String</span>( input );
    padding = <span class="hljs-built_in">String</span>( padding );
    maxLength = toInteger( maxLength );

    <span class="hljs-keyword">var</span> iLength = input.length;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit for the empty padding</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( maxLength &lt;= iLength || !padding ) <span class="hljs-keyword">return</span> input;

    <span class="hljs-keyword">var</span> pLength = padding.length &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// fast double</span>

    <span class="hljs-keyword">while</span> ( input.length + pLength &lt;= maxLength ) {
      input = padding + input + padding;
    }

    <span class="hljs-keyword">return</span> input;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>strips <code>prefix</code> from the left of <code>input</code>
<code>n</code> times. to strip <code>prefix</code> as long
as it remains a prefix to the result, pass <code>Infinity</code> or <code>INFINITY</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>prefix</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to remove)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(-)</p>
<p>Example:</p>
<p>Stryng.stripLeft(&#39;lefty loosy&#39;, &#39;lefty &#39;);
// returns &#39;loosy&#39;</p>
<p>Stryng.stripLeft(&#39;blubblubblub&#39;, &#39;blub&#39;);
// returns the empty string</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  stripLeft: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, prefix, n )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>parse <code>prefix</code> to string</li>
<li>early exit before processing senseless arguments</li>
<li>set an index <code>pending_i</code> to zero</li>
<li>increment it by <code>prefix.length</code> as long as fast native
<em>String#indexOf</em> returns just the result of that addition
and we are not running out of <code>n</code>.</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    n = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;
    prefix = <span class="hljs-built_in">String</span>( prefix );

    <span class="hljs-keyword">if</span> ( !n || !prefix ) <span class="hljs-keyword">return</span> input;

    <span class="hljs-keyword">var</span> prefix_len = prefix.length,
      pending_i = <span class="hljs-number">0</span>, i;

    <span class="hljs-keyword">do</span> i = input.indexOf( prefix, pending_i );
    <span class="hljs-keyword">while</span> ( n-- &amp;&amp; i === pending_i &amp;&amp; ( pending_i += prefix_len ) );

    <span class="hljs-keyword">return</span> pending_i ? input.substring( pending_i ) : input;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>the right-associative version of <a href="#stripLeft">Stryng.stripLeft</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>suffix</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong><br/>(string to remove)</li>
<li><strong><code>n</code> must be a number and has a default value of Math.pow(2,.</strong><br/>(32) - 1] number of operations.)</li>
</ul>
<p><strong>Returns a string</strong><br/>(-)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  stripRight: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, suffix, n )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>n</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>parse <code>suffix</code> to string</li>
<li>early exit before processing senseless arguments</li>
<li>set an index <code>p</code> to <code>input.length</code></li>
<li>decrement it by <code>suffix.length</code> as long as fast native
<em>String#lastIndexOf</em> returns just the result of that subtraction
and we are not running out of <code>n</code>.</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    n      = ( n === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n ) &gt;&gt;&gt; <span class="hljs-number">0</span>;
    suffix = <span class="hljs-built_in">String</span>( suffix );

    <span class="hljs-keyword">if</span> ( !n || !suffix ) <span class="hljs-keyword">return</span> input;

    <span class="hljs-keyword">var</span>
      suffix_len = suffix.length,
      pending_i  = input.length,
      i;

    <span class="hljs-keyword">do</span> {
      pending_i -= suffix_len;
      i          = input.lastIndexOf( suffix, pending_i );
    }
    <span class="hljs-keyword">while</span> ( n-- &amp;&amp; i !== -<span class="hljs-number">1</span> &amp;&amp; i === pending_i );

    <span class="hljs-keyword">return</span> input.substring( <span class="hljs-number">0</span>, pending_i + suffix_len );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>the combination of <a href="#stripLeft">Stryng.stripLeft</a> and <a href="#stripRight">Stryng.stripRight</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>outfix</code> must be a string.</strong><br/>(string to remove)</li>
<li><strong><code>n</code> is optional, must be a number, and has a default value of 1.</strong><br/>(number of operations (recursion depth))</li>
</ul>
<p><strong>Returns a string</strong><br/>(- )</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  strip: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, outfix, n )</span> {</span>
    <span class="hljs-keyword">return</span> Stryng.stripRight( Stryng.stripLeft( input, outfix, n ), outfix, n );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>maxLength</code> must be a number.</strong></li>
<li><strong><code>ellipsis</code> is optional, must be a string, and has a default value of &quot;...&quot;.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the <code>input</code> sliced to fit the given <code>maxLength</code> including the <code>ellipsis</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  truncate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, maxLength, ellipsis )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>parse <code>maxLength</code> with <code>toUInt32</code>, default to <code>Math.pow(2, 32) - 1</code></li>
<li>if <code>maxLength</code> is zero return the empty string</li>
<li>if <code>maxLength</code> is bigger than <code>input.length</code>
there&#39;s to need to truncate, return this&#39; string</li>
<li>parse <code>ellipsis</code> to string, default to <code>&#39;...&#39;</code></li>
<li>if <code>ellipsis.length</code> is bigger than <code>maxLength</code>,
return the last <code>maxLength</code> characters of <code>ellipsis</code></li>
<li>return the concatenation of this&#39; string&#39;s first
<code>maxLength - ellipsis_len</code> characters and <code>ellipsis</code></li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    maxLength = ( maxLength === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : maxLength ) &gt;&gt;&gt; <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> ( !maxLength ) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> ( maxLength &gt;= input.length ) <span class="hljs-keyword">return</span> input;

    ellipsis = ellipsis !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-built_in">String</span>( ellipsis ) : <span class="hljs-string">'...'</span>;

    <span class="hljs-keyword">var</span> ellipsis_len = ellipsis.length;

    <span class="hljs-keyword">if</span> ( ellipsis_len &gt;= maxLength ) <span class="hljs-keyword">return</span> ellipsis.slice( -maxLength );

    <span class="hljs-keyword">return</span> input.substring( <span class="hljs-number">0</span>, maxLength - ellipsis_len ) + ellipsis;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong><br/>(- the <code>input</code> wrapped in double quotes)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  quote: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><ul>
<li>delegate to native <em>JSON.stringify</em> if available</li>
<li>fast forwardly iterate over this&#39; string otherwise<ul>
<li>preserve ASCII printables</li>
<li>use short escape characters</li>
<li>use hexadecimal notation as a last resort, whichever is shortest</li>
</ul>
</li>
<li>wrap <code>result</code> in double quotes and return it</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    
    <span class="hljs-keyword">if</span> ( JSON_stringify ) {
      <span class="hljs-keyword">return</span> JSON_stringify( input );
    }

    <span class="hljs-keyword">var</span>
      result = <span class="hljs-string">''</span>,
      length = input.length,
      i      = <span class="hljs-number">0</span>,
      char_code;

    <span class="hljs-keyword">for</span> (; i &lt; length; i++) {
      char_code = input.charCodeAt( i );

      result +=
      
      char_code === <span class="hljs-number">34</span> ? <span class="hljs-string">"\\\""</span>: <span class="hljs-comment">// double quote</span>
      <span class="hljs-number">31</span> &lt; char_code &amp;&amp; char_code &gt; <span class="hljs-number">127</span> ? String_fromCharCode( char_code ) : <span class="hljs-comment">// ASCII printables</span>
      char_code === <span class="hljs-number">8</span>  ? <span class="hljs-string">"\\b"</span> : <span class="hljs-comment">// backspace</span>
      char_code === <span class="hljs-number">9</span>  ? <span class="hljs-string">"\\t"</span> : <span class="hljs-comment">// tab</span>
      char_code === <span class="hljs-number">10</span> ? <span class="hljs-string">"\\n"</span> : <span class="hljs-comment">// new line</span>
      char_code === <span class="hljs-number">12</span> ? <span class="hljs-string">"\\f"</span> : <span class="hljs-comment">// form feed</span>
      char_code === <span class="hljs-number">13</span> ? <span class="hljs-string">"\\r"</span> : <span class="hljs-comment">// carriage return</span>
      char_code === <span class="hljs-number">92</span> ? <span class="hljs-string">"\\\\"</span>: <span class="hljs-comment">// backslash</span>
      ( 
        char_code &lt; <span class="hljs-number">256</span> ?
        <span class="hljs-string">'\\x'</span> + ( char_code &lt; <span class="hljs-number">16</span>   ? <span class="hljs-string">'0'</span> : <span class="hljs-string">''</span> ) :
        <span class="hljs-string">'\\u'</span> + ( char_code &lt; <span class="hljs-number">4096</span> ? <span class="hljs-string">'0'</span> : <span class="hljs-string">''</span> )
      ) + char_code.toString( <span class="hljs-number">16</span> );
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">'"'</span> + result + <span class="hljs-string">'"'</span>;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>charset</code> is optional, must be a string, and has a default value of &quot;undefined&quot;.</strong></li>
</ul>
<p><strong>Returns a boolean</strong><br/>(whether <code>input</code> consists of characters within <code>charset</code> exclusively)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  consistsOf: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, charset )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    charset = <span class="hljs-built_in">String</span>( charset );

    <span class="hljs-keyword">var</span> i = input.length;

    <span class="hljs-keyword">while</span>( i-- &amp;&amp; charset.indexOf( input.charAt( i ) ) !== -<span class="hljs-number">1</span> );

    <span class="hljs-keyword">return</span> i === -<span class="hljs-number">1</span>;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>length</code> is optional, must be a number, and has a default value of input.length.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- string of length <code>length</code> with characters randomly choosen from this&#39; string)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  randomize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input, length )</span> {</span>
    <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> || length &lt;= -<span class="hljs-number">1</span> || length == INFINITY ) exit();

    input  = <span class="hljs-built_in">String</span>( input );
    length = length &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( length ) || <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">while</span>( length--){
      result += input.charAt( Math_floor( Math_random() * length ) );
    }

    <span class="hljs-keyword">return</span> result;
  },

  shuffle: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span>{</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    <span class="hljs-keyword">var</span>
      characters = input.split(<span class="hljs-string">''</span>),
      result     = <span class="hljs-string">''</span>,
      i          = characters.length;

    <span class="hljs-keyword">while</span>( i-- ){
      result += characters.splice( Math_floor( Math_random() * i ), <span class="hljs-number">1</span> )[<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">return</span> result;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a number[]</strong><br/>(- an array of char code numbers representing this&#39; string.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  ord: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    <span class="hljs-keyword">var</span>
      i      = input.length,
      result = <span class="hljs-built_in">Array</span>( i );

    <span class="hljs-keyword">while</span>( i-- ) result[ i ] = input.charCodeAt( i );

    <span class="hljs-keyword">return</span> result;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>prepends the prefixes to this&#39; string in the given order.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>prefix</code> must be any number of strings.</strong><br/>(an arbitrary number of strings to prepend recursivelyin the given order)</li>
</ul>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  prepend: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( <span class="hljs-comment">/* input, prefix.. */</span>)</span> {</span>
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>, input, i;

    <span class="hljs-keyword">if</span> ( args[ <span class="hljs-number">0</span> ] == <span class="hljs-literal">null</span> ) exit();
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>append to reversely</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    i = args.length,
    input = <span class="hljs-built_in">String</span>( args[ --i ] );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>implies parsing <code>args[ i ]</code></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">while</span> ( i-- ) input += args[ i ];

    <span class="hljs-keyword">return</span> input; 
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>Parameters:</p>
<ul>
<li><strong><code>comparable</code> is optional, must be any number of strings, and has a default value of &quot;undefined&quot;.</strong><br/>(strings to compare with)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(- whether or not this&#39; string strictly equals the string representation of all <code>comparable</code>s)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  isEqual: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input <span class="hljs-comment">/*, comparable.. */</span> )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();

    <span class="hljs-keyword">var</span> comparables = <span class="hljs-built_in">arguments</span>, <span class="hljs-comment">// promote compression</span>
      i = comparables.length;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit if no comparables passed</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( i === <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> input === <span class="hljs-string">'undefined'</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>exclude comparing <code>input</code> to itself by pre-decrementing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">while</span> ( --i &amp;&amp; input === <span class="hljs-built_in">String</span>( comparables[ i ] ) );

    <span class="hljs-keyword">return</span> !i;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>case-insensitive version of <a href="#isEqual">Stryng.isEqual</a></p>
<p>Parameters:</p>
<ul>
<li><strong><code>comparable</code> is optional, must be any number of strings, and has a default value of &#39;undefined&#39;.</strong><br/>(strings to compare with)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(-)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  isEquali: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input <span class="hljs-comment">/*, comparable.. */</span> )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ).toLowerCase() : exit();

    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>, <span class="hljs-comment">// promote compression</span>
      i = args.length;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>early exit if no comparables passed</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span> ( i === <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> input === <span class="hljs-string">'undefined'</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>break on zero by pre-decrementing</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">while</span> ( --i &amp;&amp; input === <span class="hljs-built_in">String</span>( args[ i ] ).toLowerCase() );

    <span class="hljs-keyword">return</span> !i;
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a boolean</strong><br/>(- whether the string has length <code>0</code>)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> ? !<span class="hljs-built_in">String</span>( input ) : exit();
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a boolean</strong><br/>(- whether the string is empty or consists of whitespace only)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  isBlank: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    input = input != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">String</span>( input ) : exit();
    <span class="hljs-keyword">return</span> !input || !re_no_whitespace.test( input );
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  camelCase: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  underscore: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  dasherize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  slugify: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  unquote: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>splits a string at the given indices.</p>
<p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  splitAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input <span class="hljs-comment">/* indices */</span> )</span> {</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  },
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><strong>Returns a string</strong></p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  countMultiple: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input <span class="hljs-comment">/* search string */</span> )</span> {</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not yet implemented'</span>);
  }
};
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="static-functions"><a href="#static-functions" class="anchor"></a>static functions</h1></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>generates a string of random characters which default to the ASCII printables.
to choose randomly from the whole Unicode table call <code>Stryng.random(n, 0, -1)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>length</code> is optional, must be a number, and has a default value of 0.</strong></li>
<li><strong><code>from</code> is optional, must be a number, and has a default value of 32.</strong></li>
<li><strong><code>to</code> is optional, must be a number, and has a default value of 126.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- string of length <code>n</code> with characters randomly choosen from the Unicode table with code-range [<code>from</code>, <code>to</code>])</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">Stryng.random = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( length, from, to )</span> {</span>
  <span class="hljs-keyword">if</span> ( length &lt;= -<span class="hljs-number">1</span> || length == INFINITY ) exit();

  length = length &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Math_floor( length ) || <span class="hljs-number">0</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>printable ASCII characters by default</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">  from = from === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-number">32</span>  : ( from &gt;&gt;&gt; <span class="hljs-number">0</span> );
  to   = to   === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-number">126</span> : ( to   &gt;&gt;&gt; <span class="hljs-number">0</span> );

  <span class="hljs-keyword">if</span>( to &gt; MAX_CHARCODE ) exit();

  <span class="hljs-keyword">var</span>
    result = <span class="hljs-string">''</span>,
    diff   = to - from;

  <span class="hljs-keyword">if</span> ( diff &gt; <span class="hljs-number">0</span> ) {
    <span class="hljs-keyword">while</span> ( length-- ) {
      result += String_fromCharCode( from + Math_floor( Math_random() * diff ) );
    }
  }

  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">if</span> ( DEBUG ) Stryng.random._name = <span class="hljs-string">'random'</span>;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>delegates to native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">String.fromCharCode</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>charCode</code> must be any number of numbers.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- the concatenated string representations of the given <code>charCode</code>s from the UTF-16 table. empty if no arguments passed)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">Stryng.chr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( <span class="hljs-comment">/* charCodes,... */</span> )</span> {</span>
  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>, i = args.length;
  <span class="hljs-keyword">while</span>( i-- ) <span class="hljs-keyword">if</span>( args[ i ] &gt; MAX_CHARCODE ) exit();
  <span class="hljs-keyword">return</span> String_fromCharCode.apply( <span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span> );
};

<span class="hljs-keyword">if</span>( DEBUG ) Stryng.chr._name = <span class="hljs-string">'chr'</span>; 
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 function Stryng.fromCharCode
</span></p>
<p>delegate directly to native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">String.fromCharCode</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong><code>charCode</code> is optional and must be a number.</strong></li>
</ul>
<p><strong>Returns a string</strong><br/>(- string representation of the given <code>charCode</code>s from the UTF-16 table or the empty string if no arguments passed.)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">Stryng.fromCharCode = String_fromCharCode;
Stryng.fromCodePoint = String_fromCodePoint;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="building-stryng"><a href="#building-stryng" class="anchor"></a>building stryng</h1></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="custom-methods"><a href="#custom-methods" class="anchor"></a>custom methods</h2><ul>
<li>provide a closure for each wrapper function</li>
<li>in <em>DEBUG</em> mode assign <code>_name</code> property to the function to make
our custom <a href="#exit">exit</a> method work</li>
<li>populate the custom static function <code>fn</code> onto the <em>Stryng</em> namespace</li>
<li>populate the function onto Stryng&#39;s prototype wrapped in another which..</li>
<li>unshifts the <em>Stryng</em> instance&#39;s wrapped <code>_value</code>
to become the first argument among the proxied ones to the static function</li>
<li>decides upon the type of <code>result</code> and whether this <code>_isMutable</code> what to return.<ul>
<li>if <code>result</code> isn&#39;t a string at all, simply return it</li>
<li>if the instance <code>_isMutable</code>, assign <code>result</code> to <code>_value</code> and return <code>this</code></li>
<li>if not, return a new instance of <em>Stryng</em> constructed from <code>result</code></li>
</ul>
</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">object_forOwn.call( stryng_members, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( fn, fn_name )</span> {</span>

  <span class="hljs-keyword">if</span>( DEBUG ) fn._name = fn_name;

  Stryng[ fn_name ] = fn;

  Stryng.prototype[ fn_name ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-comment">/* proxied arguments */</span>)</span> {</span>
    
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>, result;

    array_unshift.call( args, <span class="hljs-keyword">this</span>._value );
    result = fn.apply( <span class="hljs-literal">null</span>, args );

    <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'string'</span> ){ <span class="hljs-comment">// we can rest assured that this is a primitive</span>
      <span class="hljs-keyword">if</span>( <span class="hljs-keyword">this</span>._isMutable ){
        <span class="hljs-keyword">this</span>._value = result;
        <span class="hljs-keyword">if</span> ( !Object_defineProperty ){
          <span class="hljs-keyword">this</span>.length = result.length;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( result );
      }
    }
    <span class="hljs-keyword">return</span> result;
  };
} );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="native-methods"><a href="#native-methods" class="anchor"></a>native methods</h2><ul>
<li>provide a closure for each wrapper function</li>
<li>skip functions that need stay shimmed</li>
<li>populate the native static function <code>String[ fn_name ]</code> onto the
<em>Stryng</em> namespace if it exists, otherwise construct one from the equivalent
instance method <code>fn</code> as learned from <a href="http://bonsaiden.github.io/JavaScript-Garden/#function.arguments">javascript garden</a></li>
<li>in <em>DEBUG</em> mode assign <code>_name</code> property to the function to make
our custom <a href="#exit">exit</a> method work</li>
<li>populate the function onto Stryng&#39;s prototype wrapped in another which..</li>
<li>calls the native instance method in the context of the Stryng
instance&#39;s wrapped <code>_value</code></li>
<li>proxies the given <code>arguments</code></li>
<li>decides upon the type of <code>result</code> and whether this <code>_isMutable</code> what to return.<ul>
<li>if the result isn&#39;t a string at all, simply return it</li>
<li>if the instance <code>_isMutable</code>, set the value and return <code>this</code></li>
<li>if not, return a new instance of <em>Stryng</em> constructed from the result</li>
</ul>
</li>
</ul>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">array_forEach.call( methods, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( fn_name )</span> {</span>

  <span class="hljs-keyword">var</span> fn = string[ fn_name ];

  <span class="hljs-keyword">if</span> ( is.Function( fn ) &amp;&amp; shim_methods.indexOf(fn_name) === -<span class="hljs-number">1</span>) {
    
    Stryng[ fn_name ] = <span class="hljs-built_in">String</span>[ fn_name ] || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( input )</span> {</span>
      <span class="hljs-keyword">if</span> ( input == <span class="hljs-literal">null</span> ) exit();
      <span class="hljs-keyword">return</span> function_call.apply( fn, <span class="hljs-built_in">arguments</span> )
    }</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><p>the above is equivalent to</p>
<pre><code><span class="hljs-keyword">Function</span>.bind.<span class="hljs-keyword">call</span>( <span class="hljs-keyword">Function</span>.<span class="hljs-keyword">call</span>, fn )
</code></pre></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">    <span class="hljs-keyword">if</span>( DEBUG ) Stryng[ fn_name ]._name = fn_name;

    Stryng.prototype[ fn_name ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-comment">/* proxied arguments */</span>)</span> {</span>
      
      <span class="hljs-keyword">var</span> result = fn.apply( <span class="hljs-keyword">this</span>._value, <span class="hljs-built_in">arguments</span> );

      <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'string'</span> ){ <span class="hljs-comment">// we can rest assured that this is a primitive</span>
        <span class="hljs-keyword">if</span>( <span class="hljs-keyword">this</span>._isMutable ){
          <span class="hljs-keyword">this</span>._value = result;
          <span class="hljs-keyword">if</span> ( !Object_defineProperty ){
            <span class="hljs-keyword">this</span>.length = result.length;
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stryng( result );
        }
      }
      <span class="hljs-keyword">return</span> result;
    };
  }
} );
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="seemlessness"><a href="#seemlessness" class="anchor"></a>seemlessness</h2><p>by overriding <code>valueOf</code> and <code>toString</code> on the prototype
chain, instances of <em>Stryng</em> can be used like native ones
in many situations:</p>
<pre><code><span class="hljs-keyword">var</span> numeric = Stryng(<span class="hljs-string">'123'</span>);
!numeric; <span class="hljs-comment">// false</span>
+numeric; <span class="hljs-comment">// 123</span>
<span class="hljs-keyword">var</span> greeting = Stryng(<span class="hljs-string">'Hello'</span>);
greeting + <span class="hljs-string">' World!'</span> <span class="hljs-comment">// 'Hello World'</span>
<span class="hljs-keyword">var</span> dictionary = {};
dictionary[ greeting ] = <span class="hljs-string">'Salut'</span>; <span class="hljs-comment">// {'Hello': 'Salut'}</span>
</code></pre><p>however, there are exceptions to this:</p>
<pre><code><span class="hljs-keyword">var</span> stryng = Stryng();
<span class="hljs-keyword">typeof</span> stryng; <span class="hljs-comment">// 'object'</span>
stryng <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>; <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(stryng); <span class="hljs-comment">// '[object Object]'</span>
</code></pre><p>a viable check is</p>
<pre><code>stryng instanceof <span class="hljs-constant">Stryng</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>
</code></pre><p>but only for as long as <code>stryng</code> was actually constructed using
that specific <code>Stryng</code> constructor and not some other foreign (i)frame&#39;s one.</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">Stryng.prototype.valueOf =
Stryng.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value
}
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="aliases"><a href="#aliases" class="anchor"></a>aliases</h2></div>
        </div>
      
      
        <div class="code"><pre class="wrapper">object_forOwn.call( stryng_members, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( fn, fn_name )</span> {</span>

  <span class="hljs-keyword">var</span> alias = <span class="hljs-keyword">new</span> Stryng( fn_name );

  <span class="hljs-keyword">if</span> ( alias.endsWith( <span class="hljs-string">'Left'</span> ) ) {
    alias = alias.stripRight( <span class="hljs-string">'Left'</span> ).prepend( <span class="hljs-string">'l'</span> );

    Stryng[ alias ] = fn;
    Stryng.prototype[ alias ] = Stryng.prototype[ fn_name ];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( alias.endsWith( <span class="hljs-string">'Right'</span> ) ) {
    alias = alias.stripRight( <span class="hljs-string">'Right'</span> ).prepend( <span class="hljs-string">'r'</span> );

    Stryng[ alias ] = fn;
    Stryng.prototype[ alias ] = Stryng.prototype[ fn_name ];
  }
} );

Stryng.shallowStringify = Stryng.quote;
Stryng.prototype.shallowStringify = Stryng.prototype.quote;

Stryng.append = Stryng.concat;
Stryng.prototype.append = Stryng.prototype.concat;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h2 id="export"><a href="#export" class="anchor"></a>export</h2></div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p>restores the provious value assigned to <code>window.Stryng</code> if it
is different from <code>undefined</code>, otherwise cleans up the global namespace with <code>delete</code>.</p>
<p><strong>Returns a Stryng</strong><br/>(- the inner reference <em>Stryng</em> holds to itself)</p>
</div>
        </div>
      
      
        <div class="code"><pre class="wrapper">Stryng.noConflict = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span>( <span class="hljs-keyword">typeof</span> window !== <span class="hljs-string">'object'</span> || window.window !== window ) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">if</span> ( is.Undefined( previous_Stryng ) ) {
    <span class="hljs-keyword">delete</span> window.Stryng;
  } <span class="hljs-keyword">else</span> {
    window.Stryng = previous_Stryng;
  }
  <span class="hljs-keyword">return</span> Stryng;
}

module.exports = Stryng;
</pre></div>
      
      </div>
    
      <div class="segment">
      
        <div class="comments doc-section">
          <div class="wrapper"><p><span class='doc-section-header'>
 callback contribution
</span></p>
<p>Parameters:</p>
<ul>
<li><p><strong><code>input</code> must be a string.</strong><br/>(the string to work on)
{...*}</p>
<p>String literal ( with <code>string instanceOf String</code> yielding false )</p>
</li>
</ul>
</div>
        </div>
      
      
      </div>
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script></div>
        </div>
      
      
      </div>
    
    </div>
  </div>

  <script src="../toc.js"></script>
  <script src="../assets/libs.js"></script>
  <script src="../assets/behavior.js"></script>
</body>
</html>